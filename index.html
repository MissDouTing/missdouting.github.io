<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>小豆子的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1630473019367.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="MissDou">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>小豆子的博客</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-56_Math、Array、String的方法和属性"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkwo7zn0004pov9hsj5enki.html">56_Math、Array、String的方法和属性</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="Math对象的常用方法"><a href="#Math对象的常用方法" class="headerlink" title="Math对象的常用方法"></a>Math对象的常用方法</h2><pre><code>console.log(Math.PI); //圆周率3.141592653589793
Math.random();//介于 0 和 1 之间的伪随机数。
Math.ceil(6.6);//获取大于或等于提供数值的最小整数--向上取整
Math.floor(8.8);//获取小于或等于提供数值的最大整数--向下取整
Math.round(9.9);//四舍五入
Math.max(10,20,15);//取多个值中的最大值
Math.min(10,20,15);//取多个值中的最小值
Math.pow(10,2);//返回x的y次幂
Math.sqrt(100);//求平方根
</code></pre>
<h2 id="Array的属性和方法"><a href="#Array的属性和方法" class="headerlink" title="Array的属性和方法"></a>Array的属性和方法</h2><pre><code>属性： constructor  返回对创建此对象的数组函数的引用。
            length          设置或返回数组中元素的数目。
            prototyp        可以向对象添加属性和方法。

方法： concat()        连接两个或更多的数组，并返回结果。
            join()            把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。
            pop()            删除并返回数组的最后一个元素
            push()            向数组的末尾添加一个或更多元素，并返回新的长度。
            reverse()       颠倒数组中元素的顺序。
            shift()            删除并返回数组的第一个元素
            slice()             从某个已有的数组返回选定的元素
            sort()              对数组的元素进行排序
            splice()          删除元素，并向数组添加新元素。
            toString()      把数组转换为字符串，并返回结果。
            unshift()        向数组的开头添加一个或更多元素，并返回新的长度。
            valueOf()        返回数组对象的原始值
             some()           数组中任何一个元素是否满足指定要求就会返回true，所有元素不满足指定条件就返回false   
             every()          数组中所有元素都满足指定条件才会返回true
             filter()         过滤数据，返回新的数据
             map()            遍历数组，返回新的 数据
             forEach()        遍历数组
             findIndex()      根据条件查询下标
             reduce()         累计运算
</code></pre>
<h2 id="String的属性和方法"><a href="#String的属性和方法" class="headerlink" title="String的属性和方法"></a>String的属性和方法</h2><pre><code>属性：constructor  返回对创建此对象的数组函数的引用。
            length          设置或返回数组中元素的数目。
            prototyp        可以向对象添加属性和方法。

方法：charAt()       返回在指定位置的字符。
            concat()      连接字符串。
            indexOf()   检索字符串。
            match()    找到一个或多个正则表达式的匹配。
            replace()    替换与正则表达式匹配的子串。
            slice()            提取字符串的片断，并在新的字符串中返回被提取的部分。
            split()            把字符串分割为字符串数组
            sub()            把字符串显示为下标。
            sup()                把字符串显示为上标。
            toLowerCase()    把字符串转换为小写。
            toUpperCase()  把字符串转换为大写。
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:44:26.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-55_jquery的选择器"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkwo7zn0003pov97fd1c6ge.html">55_jquery的选择器</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>一、基本选择器(5种)

基本选择器是jQuery中最常用也是最简单的选择器，它通过元素的id、class和标签名等来查找DOM元素。

1、ID选择器 #id
描述：根据给定的id匹配一个元素， 返回单个元素（注：在网页中，id名称不能重复）
示例：$(&quot;#test&quot;) 选取 id 为 test 的元素

2、类选择器 .class
描述：根据给定的类名匹配元素，返回元素集合
示例：$(&quot;.test&quot;) 选取所有class为test的元素

3、元素(标签)选择器 element
描述：根据给定的元素名匹配元素，返回元素集合
示例：$(&quot;p&quot;) 选取所有的&lt;p&gt;元素 $(&quot;div&quot;) :选取所有的div标签

4、*
描述：匹配所有元素，返回元素集合
示例：$(&quot;*&quot;) 选取所有的元素

5、selector1，selector2,...,selectorN（并集选择器）
描述：将每个选择器匹配到的元素合并后一起返回，返回合并后的元素集合
示例：$(&quot;p,span,p.myClass&quot;) 选取所有&lt;p&gt;,&lt;span&gt;和class为myClass的&lt;p&gt;标签的元素集合

二、层次选择器(4种)

层次选择器根据层次关系获取特定元素。

1、后代选择器 
示例：$(&quot;p span&quot;) 选取&lt;p&gt;元素里的所有的&lt;span&gt;元素（注：后代选择器选择父元素所有指定选择的元素，不管是儿子级，还是孙子级）

2、子选择器 $(&quot;parent&gt;child&quot;)
示例：$(&quot;p&gt;span&quot;) 选择&lt;p&gt;元素下的所有&lt;span&gt;元素 （注：子选择器只选择直属于父元素的子元素）

3、兄弟选择器 $(&quot;prev+next&quot;)
描述：选取紧接在prev元素后的next元素，返回元素集合
示例：$(&quot;.one+p&quot;) 选取class为one的下一个&lt;p&gt;同辈元素集合

4、兄弟选择器 $(&quot;prev~siblings&quot;)
描述：选取prev元素后的所有siblings元素，返回元素集合
示例：$(&quot;#two~p&quot;)选取id为two的元素后所有&lt;p&gt;同辈元素集合

三、过滤选择器(5种)
1基本过滤选择器

1、 :first
描述：选取第一个元素，返回单个元素
示例：$(&quot;p:first&quot;) 选取所有&lt;p&gt;元素中第一个&lt;p&gt;元素
2、 :last
描述：选取最后一个元素，返回单个元素
示例：$(&quot;p:last&quot;) 选取所有&lt;p&gt;元素中最后一个&lt;p&gt;元素
3、 :not(selector)
描述：去除所有与给定选择器匹配的元素，返回元素集合
示例：$(&quot;input:not(.myClass)&quot;) 选取class不是myClass的&lt;input&gt;元素
4、 :even
描述：选取索引是偶数的所有元素，索引从0开始，返回元素集合
5、 :odd
描述：选取索引是奇数的所有元素，索引从0开始，返回元素集合
6、 :eq(index)
描述：选取索引等于index的元素，索引从0开始，返回单个元素
7、 :gt(index)
描述：选取索引大于index的元素，索引从0开始，返回元素集合
8、 :lt(index)
描述：选取索引小于于index的元素，索引从0开始，返回元素集合
9、 :focus
描述：选取当前获取焦点的元素

2、内容过滤选择器

1、:contains(text)
描述：选取含有文本内容为text的元素，返回元素集合
示例：$(&quot;p:contains(&#39;我&#39;)&quot;) 选取含有文本“我”的元素
2、:empty
描述：选取不包含子元素或者文本元素的空元素，返回元素集合
示例：$(&quot;p:empty&quot;) 选取不包含子元素或者文本元素的空&lt;p&gt;元素（&lt;p&gt;&lt;/p&gt;）
3、:has(selector)
描述：选取含有选择器所匹配的元素的元素，返回元素集合
示例：$(&quot;p:has(p)&quot;) 选取含有&lt;p&gt;元素的&lt;p&gt;元素（&lt;p&gt;&lt;p/&gt;&lt;/p&gt;）
4、:parent
描述：选取含有子元素或者文本的元素，返回元素集合
示例：$(&quot;p:parent&quot;) 选取含有子元素或者文本元素的&lt;p&gt;元素（&lt;p&gt;&lt;p/&gt;&lt;/p&gt;或者&lt;p&gt;文本&lt;/p&gt;）

3、可见性过滤选择器

1、:hidden
描述：选取所有不可见的元素，返回元素集合
2、:visible
描述：选取所有可见的元素，返回元素集合

4、属性过滤选择器（返回元素集合）

1、[attribute]
示例：$(&quot;p[id]&quot;) 选取拥有id属性的p元素
2、[attribute=value]
示例：$(&quot;input[name=text]&quot;) 选取拥有name属性等于text的input元素
3、[attribute!=value]
示例：$(&quot;input[name!=text]&quot;) 选取拥有name属性不等于text的input元素
4、[attribute^=value]
示例：$(&quot;input[name^=text]&quot;) 选取拥有name属性以text开始的input元素
5、[attribute$=value]
示例：$(&quot;input[name$=text]&quot;) 选取拥有name属性以text结束的input元素
6、[attribute=value]
示例：$(&quot;input[name=text]&quot;) 选取拥有name属性含有text的input元素
7、[attribute~=value]
示例：$(&quot;input[class~=text]&quot;) 选取拥有class属性以空格分割的值中含有text的input元素
8、attribute1[attributeN]
描述：合并多个属性过滤选择器

5、表单对象属性过滤选择器（返回元素集合）

1、:enabled
描述：选取所有可用元素
2、:disabled
描述：选取所有不可用元素
3、:checked
描述：选取所有被选中的元素（单选框，复选框）
示例：$(&quot;input:checked&quot;) 选取所有被选中的&lt;input&gt;元素
4、:selected
描述：选取所有被选中的选项元素（下拉列表）
示例：$(&quot;select option:selected&quot;) 选取所有被选中的选项元素

四、表单选择器（返回元素集合，使用相似）

1、:text
描述：选择所有的单行文本框
示例：$(&quot;:text&quot;)选取所有的单行文本框
2、:password
描述：选择所有的密码框
3、:button
描述：选择所有的按钮
4、:checkbox
描述：选择所有的多选框
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:41:44.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-54_本地存储和离线缓存的区别"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkwo7zm0002pov99rondnf2.html">54_本地存储和离线缓存的区别</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="1-本地存储和离线缓存区别："><a href="#1-本地存储和离线缓存区别：" class="headerlink" title="1.本地存储和离线缓存区别："></a>1.本地存储和离线缓存区别：</h2><ul>
<li>本地存储主要是将网站会话过程中的数据保存在客户端，突破了原来cookie存储大小的限制，相当于一个针对于前端页面的数据库。</li>
<li>离线缓存主要作用是让用户在没有网络的情况下仍然可以访问缓存的网页，可以减少服务器的负载</li>
<li>本地存储一般存储的都是数据，而离线缓存一般存储的是网页等</li>
</ul>
<h2 id="2-本地存储的用法"><a href="#2-本地存储的用法" class="headerlink" title="2.本地存储的用法"></a>2.本地存储的用法</h2><pre><code>localStorage.setItem(&quot;key&quot;,&quot;value&quot;);//存储
localStorage.getItems(key);//按key进行取值
localStorage.removeItems(key);//按key单个删除
localStorage.clear();//删除全部数据
localStorage.length;//获得数据的数量
localStorage.valueOf();//获取全部值
</code></pre>
<h2 id="3-离线缓存的用法"><a href="#3-离线缓存的用法" class="headerlink" title="3.离线缓存的用法"></a>3.离线缓存的用法</h2><p>​    a. 在html标签添加manifest属性<br>​    在页面的html标签中添加manifest属性，属性值为manifest文件的路径。如：</p>
<pre><code>&lt;!DOCTYPE HTML&gt; 
        &lt;html manifest=&quot;../js/demo.manifest&quot;&gt;
                ...
        &lt;/html&gt;
</code></pre>
<p>b. 编写manifest文件<br>manifest文件是简单的文本文件，它会告知浏览器需要缓存的内容以及不需要缓存的内容。</p>
<p>manifest文件可分为三部分：<br>(1) CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存<br>(2) NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存<br>(3) FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</p>
<p>简单示例:</p>
<pre><code>    CACHE MANIFEST
        #version 1.1   /*版本号*/
        CACHE:
            html/index.html /*需要缓存的文件*/
        NETWORK:
            js/jquery.js /*不需要缓存的文件*/
        FALLBACK: 
            html/index.html /*当页面无法访问时的回退页面*/
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:38:29.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-53_浏览器的进程"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkwo7zg0000pov97cvofrsp.html">53_浏览器的进程</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>浏览器包括四个进程：</p>
<p>1.主进程(Browser进程)，浏览器只有一个主进程，负责资源下载、界面展示等主要基础功能；<br>2.GPU进程，负责3D图示绘制<br>3.第三方插件进程，负责第三方插件处理<br>4.渲染进程(Render进程)，负责js执行，页面渲染等功能</p>
<p><strong>渲染进程中主要包括的线程及各个线程的功能</strong></p>
<pre><code>1.GUI渲染线程
 - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
 - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
 - 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

2.JS引擎线程
 - 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
 - JS引擎线程负责解析Javascript脚本，运行代码。
 - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
 - 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

3.事件触发线程
 - 用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
 - 当JS引擎执行代码块如setTimeOut时（也可是鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
 - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
 - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

4.定时触发器线程
 - 浏览器定时计数器并不是由JavaScript引擎计数的（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
 - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
 - 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

5.异步http请求线程
 - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
 - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:34:57.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-52_this指向问题"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkwo7zk0001pov9ed69ba5a.html">52_this指向问题</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>在 JavaScript 中，this 通常指向的是我们正在执行的函数本身，或者是，指向该函数所属的对象。

1. 普通函数调用，此时 this 指向 window
    function fn() &#123;
       console.log(this);   // window
    &#125;
    fn();  //  window.fn(),此处默认省略window
2. 定时器函数， 此时 this 指向 window
    setInterval(function () &#123;
       console.log(this); // window
    &#125;, 1000);
3. 构造函数调用， 此时 this 指向 实例对象
    function Person(age, name) &#123;
        this.age = age;
        this.name = name
        console.log(this)  // 此处 this 分别指向 Person 的实例对象 p1 p2
     &#125;
    var p1 = new Person(18, &#39;zs&#39;);
4. 对象方法调用， 此时 this 指向 该方法所属的对象
    var obj = &#123;
        fn: function () &#123;
            console.log(this); // obj
        &#125;
    &#125;
    obj.fn();
5.通过事件绑定的方法， 此时 this 指向 绑定事件的对象 
    btn.onclick = function() &#123;
        console.log(this); // btn
    &#125;
6.箭头函数的this：是声明函数时所在作用域中的this
    //this   window
    var obj = &#123;
        //this
        fn:  ()=&gt;&#123;
            console.log(this);   //window
        &#125;,
        fn2: function()&#123;
            //this     obj
            (()=&gt;&#123;
                console.log(this)  //obj
            &#125;)()
        &#125;
    &#125;
    obj.fn();
    obj.fn2();
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:32:58.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-51_es6常用语法"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkw1mmm000098v96qneg6ml.html">51_es6常用语法</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。</p>
<p>一、新增箭头函数</p>
<pre><code class="javascript">- 简化了写法， 少打代码，结构清晰
- 明确了this。传统JS的this是在运行的时候确定的，而不是在定义的时候确定的；而箭头函数的this是在定义时就确定的，不能被改变，也不能被call,apply,bind这些方法修改。      
</code></pre>
<p>二、块级作用域</p>
<pre><code class="javascript">- ES6中的let声明的变量有块级作用域
- ES5中是没有块级作用域的，并且var有变量提升的概念
- let声明的变量在同一个作用域内只有一个
- 要声明常量使用const
</code></pre>
<p>三、解构赋值</p>
<pre><code class="javascript">ES6中变量的解构赋值，比如：
let [a,b,c] = [0,1,2];
let &#123;foo:abc,bar&#125; = &#123;foo:&#39;hello&#39;,bar:&#39;hi&#39;&#125;;
</code></pre>
<p>四、Symbol</p>
<pre><code class="javascript">//ES6新增了一种Symbol数据类型，表示全局唯一的对象

let a1 = Symbol();
let a2 = Symbol();
console.log(a1 === a2);   //false   a1和a2永远不相等

let a3 = Symbol.for(&quot;a3&quot;);
let a4 = Symbol.for(&quot;a3&quot;);
console.log(a3 === a4);  //true
</code></pre>
<p>五、模板字符串</p>
<pre><code class="javascript">var name = &quot;张三&quot;;
var age = 12;
var gender=&quot;男&quot;;
let str = `姓名$&#123;name&#125;,年龄$&#123;age&#125;,性别$&#123;gender&#125;`;
</code></pre>
<p>六、展开运算符</p>
<pre><code class="javascript">let arr1 = [1,2,3];
let arr2 = [4,5,6];
let arr3 = [...arr1,...arr2];
</code></pre>
<p>七、类</p>
<p>ES6引入Class这个概念，让JS拥有其他面向对象语言的语法糖。</p>
<pre><code class="javascript">&#123;
  // 继承传递参数
  class Parent&#123;
    constructor(name=&#39;mukewang&#39;)&#123;
      this.name=name;
    &#125;
  &#125;

  class Child extends Parent&#123;
    constructor(name=&#39;child&#39;)&#123;
      //先初始化父亲的信息，在初始化自己的信息  
      super(name);
      this.type=&#39;child&#39;;
    &#125;
  &#125;
  console.log(&#39;继承传递参数&#39;,new Child(&#39;hello&#39;));
&#125;
</code></pre>
<p>八、Promise</p>
<pre><code class="javascript">//ES6的Promise主要用于解决JS回调地狱问题

var fs = require(&#39;fs&#39;)

function pReadFile(filePath) &#123;
  return new Promise(function (resolve, reject) &#123;
    fs.readFile(filePath, &#39;utf8&#39;, function (err, data) &#123;
      if (err) &#123;
        reject(err)
      &#125; else &#123;
        resolve(data)
      &#125;
    &#125;)
  &#125;)
&#125;

pReadFile(&#39;./data/a.txt&#39;)
  .then(function (data) &#123;
    console.log(data)
    return pReadFile(&#39;./data/b.txt&#39;)
  &#125;)
  .then(function (data) &#123;
    console.log(data)
    return pReadFile(&#39;./data/c.txt&#39;)
  &#125;)
  .then(function (data) &#123;
    console.log(data)
  &#125;)
</code></pre>
<p>九、ES6的迭代器</p>
<pre><code class="javascript">//for ... of 是ES6中新增加的语法,主要用来循环实现了Iterator接口类型的对象
//for ... of 可以遍历Array、Set、Map不能遍历Object 
let arr = [&#39;China&#39;, &#39;America&#39;, &#39;Korea&#39;]
for (let o of arr) &#123;
    console.log(o) //China, America, Korea
&#125;
</code></pre>
<p>十、ES6模块化</p>
<pre><code class="javascript">//1.导出
//导出单个成员
export let name = &#39;leo&#39;;
export let age= 30;
let name= &#39;leo&#39;;
let age= 30;
let kk = &quot;abc&quot;
//导出多个成员
export &#123;name, age&#125;;
//导出默认成员
export default kk;

//2.引入
import kk,&#123;name,age&#125; from &#39;a.js&#39;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:29:24.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-50_js模块化规范"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdq000cr0v92yrj72oj.html">50_js模块化规范</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>#requirejs  AMD前台模块化规范
1、引入模块
require([dependencies],function()&#123;&#125;);
    - 第一个参数是一个数组,表示所依赖的模块
- 第二个参数是一个回调函数,当前面指定的模块都加载成功后,它将被调用.加载的模块会以参数形式传入该函数,从而在回调函数内部就可以使用这些模块

2、定义模块
define(id?,dependencies?,factory);
    - id: 定义中模块的名字;可选；如果没有提供该参数,模块的名字应该默认为模块加载器请求的指定脚本的名字.
    - 依赖dependencies：是一个当前模块依赖的,已被模块定义的模块标识的数组字面量
    - 工厂方法factory,模块初始化要执行的函数或对象.如果为函数,它应该只被执行一次.如果是对象,此对象应该为模块的输出值.
    - 默认情况下文件名即为模块名


#seajs   CMD前台模块化规范
//声明模块
define(id?,d?,factory)
- id : 因为CMD推崇一个文件一个模块,所以经常就用文件名作为模块id
- d : CMD推崇依赖就近,所以一般不在define的参数中写依赖
- factory :函数   function(require,exports,module)
        require 是一个方法,用来获取其他模块提供的接口
        exports 是一个对象,用来向外提供模块接口
        module 是一个对象,上面存储了与当前模块相关联的一些属性和方法


//使用模块
seajs.use(&#39;mymodel.js&#39;,function(mymodel)&#123;
&#125;);



#commonjs   后台模块化规范
//1.模块的引入
const modu = require(‘./b.js’)

//2.模块的导出
//导出单个成员
exports.foo = “变量”
exports.add = function()&#123;&#125;

//导出多个成员
module.exports = &#123;
&#125;


#ES6模块化规范
//1.导出
//导出单个成员
export let name = &#39;leo&#39;;
export let age= 30;
let name= &#39;leo&#39;;
let age= 30;
let kk = &quot;abc&quot;
//导出多个成员
export &#123;name, age&#125;;
//导出默认成员
export default kk;

//2.引入
import kk,&#123;name,age&#125; from &#39;a.js&#39;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:26:30.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-49_JavaScript的严格模式"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdp000ar0v98t6yeis5.html">49_JavaScript的严格模式</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>javascript 代码中的”use strict”是使用严格模式，使用严格模式，一些不规范的语法将不再支持。</p>
<pre><code>全局变量显式声明
静态绑定
禁止使用 with 语句
eval 中定义的变量都是局部变量
禁止 this 关键字指向全局对象
禁止在函数内部遍历调用栈
严格模式下无法删除变量。只有 configurable 设置为 true 的对象属性，才能被删除
正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，
将报错。
严格模式下，对一个使用 getter 方法读取的属性进行赋值，会报错。
严格模式下，对禁止扩展的对象添加新属性，会报错。
严格模式下，删除一个不可删除的属性，会报错。
正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，
这属于语法错误。
正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于
语法错误。
正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严
格模式禁止这种表示法，整数第一位为 0，将报错。
不允许对 arguments 赋值
arguments 不再追踪参数的变化
禁止使用 arguments.callee
严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的
代码块内声明函数
严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。


严格模式的一些主要优点包括：
- 使调试更加容易。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。(实时显示错误代码，方便调试)
- 防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。(如果一个变量在没声明就赋值，这个变量会自动变成全局变量，防止意外)
- 消除 this 强制。如果没有严格模式，引用null或未定义的值到 this 值会自动强制到全局变量。这可能会导致许多令人头痛的问题和让人恨不得拔自己头发的bug。在严格模式下，引用 null或未定义的 this 值会抛出错误。
- 不允许重复的属性名称或参数值。当检测到对象（例如，var object = &#123;foo: &quot;bar&quot;, foo: &quot;baz&quot;&#125;;）中重复命名的属性，或检测到函数中（例如，function foo(val1, val2, val1)&#123;&#125;）重复命名的参数时，严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。(避免重复命名，变量，参数，等)
- 使eval() 更安全。在严格模式和非严格模式下，eval() 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在 eval() 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。(eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。)
- 在 delete使用无效时抛出错误。delete操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:24:28.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-48_减低页面加载时间的几种方法"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdo0009r0v9dtsgcq9p.html">48_减低页面加载时间的几种方法</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>1.减少http请求数量和体积
    -压缩 css、js 文件
    -合并 js、css 文件，减少 http 请求
    -使用CSS Sprites图，合并多个CSS图片，合理使用图片压缩
    -合理使用http缓存，减少http请求
    -使用外部的css和js以减少服务器的压力
    
2.css和script的位置
    把 css 样式引入放在&lt;head&gt;标签中，把 &lt;script&gt;资源引入放在&lt;/body&gt;闭合之前。
    外链脚本在加载时却常常阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。所以说尽可能的将脚本往后挪，减少对并发下载的影响
    
3.DOM操作优化
    -要避免在document上直接进行频繁的DOM操作(用innerHTML代替DOM操作)，缓存DOM节点查找的结果
    -使用classname代替大量的内联样式修改
    -对于复杂的UI元素，设置position为absolute或fixed
    -在js动画和css动画之间尽量使用css动画
    -适当使用canvas
    -使用事件代理
    -避免使用eval或Function，每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码，这是很消耗资源的操作 
    -避免大量的字符串拼接，可以使用数组的join方法

4.CSS选择符优化
    -避免使用通配符选择器，避免使用后代选择器
    -选择器匹配是从右向左匹配的，选择器语句链越短，浏览器的匹配速度越快
    -避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作
    -搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）。在写样式时，避免触发重新布局的可能
    -减少使用昂贵的属性，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价。box-shadow/border-radius/filter/透明度/:nth-child等
    -不要使用@import
    -尽量减少css表达式的使用  background-color: expression((new Date()).getHours()%2?&quot;#FFFFFF&quot;: &quot;#000000&quot; );

//附：重排和重绘的操作
-重排的操作：
    width    height    padding    margin
    display    border-width    border    top
    position    font-size    float    text-align
    overflow-y    font-weight    overflow    left
    font-family    line-height    vertical-align    right
    clear    white-space    bottom    min-height
    offsetTop  offsetLeft  offsetWidth   offsetHeight
    scrollTop   scrollLeft  scrollWidth   scrollHeight
    clientTop   clientLeft   clientWidth  clientHeight 
    getComputedStyle()    (currentStyle in IE)
 -重绘的操作：
     color    border-style    visibility    background
    text-decoration    background-image    background-position    background-repeat
    outline-color    outline    outline-style    border-radius
    outline-width    box-shadow    background-size
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:23:02.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-47_前端兼容问题的解决方案"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdq000br0v9a5cjenzy.html">47_前端兼容问题的解决方案</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>1、在 IE 下和火狐下事件冒泡不一样
//阻止冒泡的兼容性写法
function stopBubble(event)&#123;
    var e=arguments.callee.caller.arguments[0]||event;
    if(e&amp;&amp;e.stopPropagation)&#123;
        e.stopPropagation()
    &#125;else if(window.event)&#123;
        //ie
        window.event.cancelBubble=true;
    &#125;
&#125;


//阻止浏览器默认行为的兼容性写法
function stopDefault(event)&#123;
    var e=arguments.callee.caller.arguments[0]||event;
    //阻止默认浏览器动作(W3C)
    if(e&amp;&amp;e.preventDefault)&#123;
        e.preventDefault();
    &#125;else&#123;
        //IE中阻止函数默认动作的方式
        window.event.returnValue=false;      
    &#125;
    return false;
&#125;


2、IE 的写法： tbody=table.childNodes[0]
    在 FF 中，firefox 会在子节点中包含空白则第一个子节点为空白&quot;&quot;， 而 ie 不会返回空白
    可以通过 if(&quot;&quot; != node.nodeName)过滤掉空白子对象

3、模拟点击事件
if(document.all)&#123; //ie 下
    document.getElementById(&quot;a3&quot;).click();
&#125;
else&#123; //非 IE
    var evt = document.createEvent(&quot;MouseEvents&quot;);
    evt.initEvent(&quot;click&quot;, true, true);
    document.getElementById(&quot;a3&quot;).dispatchEvent(evt);
&#125;

4、事件注册
if (isIE)&#123;
   window.attachEvent(&quot;onload&quot;, init);
&#125;else&#123;
   window.addEventListener(&quot;load&quot;, function()&#123;&#125;)

5、ajax对象的获取
   IE： ActiveXObject
   其他浏览器：XMLHttpRequest

6、firstElement等返回结果不一样
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:21:19.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  

  
    <nav class="pagination">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next</a>
    </nav>
  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/" rel="tag">js的基本数据类型和引用数据类型详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8Enode%E5%90%8E%E7%AB%AF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="tag">mongodb的安装、使用，与node后端连接，前端的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%80%E4%B9%88%E6%98%AFMVVM%EF%BC%8CMVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E4%BB%A5%E5%8F%8A%E4%B8%8EMVC%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">什么是MVVM，MVVM模式的优点以及与MVC模式的区别</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E4%B8%89%E8%80%85%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86/" rel="tag">对三者的声明方式进行区分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E3%80%81%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">对象的引用、浅拷贝、深拷贝在内存中的实现过程、三者的区别</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/ckzkwo7zn0004pov9hsj5enki.html">56_Math、Array、String的方法和属性</a>
          </li>
        
          <li>
            <a href="/ckzkwo7zn0003pov97fd1c6ge.html">55_jquery的选择器</a>
          </li>
        
          <li>
            <a href="/ckzkwo7zm0002pov99rondnf2.html">54_本地存储和离线缓存的区别</a>
          </li>
        
          <li>
            <a href="/ckzkwo7zg0000pov97cvofrsp.html">53_浏览器的进程</a>
          </li>
        
          <li>
            <a href="/ckzkwo7zk0001pov9ed69ba5a.html">52_this指向问题</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <div class="footer-wrap">
        <div class="footer-inner"> 
            小豆子的博客 &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1630473019367.js"></script>


<script src="/dist/custom.js?1630473019367.js"></script>









</body>

</html>