<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>小豆子的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1630473019367.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="MissDou">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>小豆子的博客</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-51_es6常用语法"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkw1mmm000098v96qneg6ml.html">51_es6常用语法</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。</p>
<p>一、新增箭头函数</p>
<pre><code class="javascript">- 简化了写法， 少打代码，结构清晰
- 明确了this。传统JS的this是在运行的时候确定的，而不是在定义的时候确定的；而箭头函数的this是在定义时就确定的，不能被改变，也不能被call,apply,bind这些方法修改。      
</code></pre>
<p>二、块级作用域</p>
<pre><code class="javascript">- ES6中的let声明的变量有块级作用域
- ES5中是没有块级作用域的，并且var有变量提升的概念
- let声明的变量在同一个作用域内只有一个
- 要声明常量使用const
</code></pre>
<p>三、解构赋值</p>
<pre><code class="javascript">ES6中变量的解构赋值，比如：
let [a,b,c] = [0,1,2];
let &#123;foo:abc,bar&#125; = &#123;foo:&#39;hello&#39;,bar:&#39;hi&#39;&#125;;
</code></pre>
<p>四、Symbol</p>
<pre><code class="javascript">//ES6新增了一种Symbol数据类型，表示全局唯一的对象

let a1 = Symbol();
let a2 = Symbol();
console.log(a1 === a2);   //false   a1和a2永远不相等

let a3 = Symbol.for(&quot;a3&quot;);
let a4 = Symbol.for(&quot;a3&quot;);
console.log(a3 === a4);  //true
</code></pre>
<p>五、模板字符串</p>
<pre><code class="javascript">var name = &quot;张三&quot;;
var age = 12;
var gender=&quot;男&quot;;
let str = `姓名$&#123;name&#125;,年龄$&#123;age&#125;,性别$&#123;gender&#125;`;
</code></pre>
<p>六、展开运算符</p>
<pre><code class="javascript">let arr1 = [1,2,3];
let arr2 = [4,5,6];
let arr3 = [...arr1,...arr2];
</code></pre>
<p>七、类</p>
<p>ES6引入Class这个概念，让JS拥有其他面向对象语言的语法糖。</p>
<pre><code class="javascript">&#123;
  // 继承传递参数
  class Parent&#123;
    constructor(name=&#39;mukewang&#39;)&#123;
      this.name=name;
    &#125;
  &#125;

  class Child extends Parent&#123;
    constructor(name=&#39;child&#39;)&#123;
      //先初始化父亲的信息，在初始化自己的信息  
      super(name);
      this.type=&#39;child&#39;;
    &#125;
  &#125;
  console.log(&#39;继承传递参数&#39;,new Child(&#39;hello&#39;));
&#125;
</code></pre>
<p>八、Promise</p>
<pre><code class="javascript">//ES6的Promise主要用于解决JS回调地狱问题

var fs = require(&#39;fs&#39;)

function pReadFile(filePath) &#123;
  return new Promise(function (resolve, reject) &#123;
    fs.readFile(filePath, &#39;utf8&#39;, function (err, data) &#123;
      if (err) &#123;
        reject(err)
      &#125; else &#123;
        resolve(data)
      &#125;
    &#125;)
  &#125;)
&#125;

pReadFile(&#39;./data/a.txt&#39;)
  .then(function (data) &#123;
    console.log(data)
    return pReadFile(&#39;./data/b.txt&#39;)
  &#125;)
  .then(function (data) &#123;
    console.log(data)
    return pReadFile(&#39;./data/c.txt&#39;)
  &#125;)
  .then(function (data) &#123;
    console.log(data)
  &#125;)
</code></pre>
<p>九、ES6的迭代器</p>
<pre><code class="javascript">//for ... of 是ES6中新增加的语法,主要用来循环实现了Iterator接口类型的对象
//for ... of 可以遍历Array、Set、Map不能遍历Object 
let arr = [&#39;China&#39;, &#39;America&#39;, &#39;Korea&#39;]
for (let o of arr) &#123;
    console.log(o) //China, America, Korea
&#125;
</code></pre>
<p>十、ES6模块化</p>
<pre><code class="javascript">//1.导出
//导出单个成员
export let name = &#39;leo&#39;;
export let age= 30;
let name= &#39;leo&#39;;
let age= 30;
let kk = &quot;abc&quot;
//导出多个成员
export &#123;name, age&#125;;
//导出默认成员
export default kk;

//2.引入
import kk,&#123;name,age&#125; from &#39;a.js&#39;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:29:24.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-50_js模块化规范"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdq000cr0v92yrj72oj.html">50_js模块化规范</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>#requirejs  AMD前台模块化规范
1、引入模块
require([dependencies],function()&#123;&#125;);
    - 第一个参数是一个数组,表示所依赖的模块
- 第二个参数是一个回调函数,当前面指定的模块都加载成功后,它将被调用.加载的模块会以参数形式传入该函数,从而在回调函数内部就可以使用这些模块

2、定义模块
define(id?,dependencies?,factory);
    - id: 定义中模块的名字;可选；如果没有提供该参数,模块的名字应该默认为模块加载器请求的指定脚本的名字.
    - 依赖dependencies：是一个当前模块依赖的,已被模块定义的模块标识的数组字面量
    - 工厂方法factory,模块初始化要执行的函数或对象.如果为函数,它应该只被执行一次.如果是对象,此对象应该为模块的输出值.
    - 默认情况下文件名即为模块名


#seajs   CMD前台模块化规范
//声明模块
define(id?,d?,factory)
- id : 因为CMD推崇一个文件一个模块,所以经常就用文件名作为模块id
- d : CMD推崇依赖就近,所以一般不在define的参数中写依赖
- factory :函数   function(require,exports,module)
        require 是一个方法,用来获取其他模块提供的接口
        exports 是一个对象,用来向外提供模块接口
        module 是一个对象,上面存储了与当前模块相关联的一些属性和方法


//使用模块
seajs.use(&#39;mymodel.js&#39;,function(mymodel)&#123;
&#125;);



#commonjs   后台模块化规范
//1.模块的引入
const modu = require(‘./b.js’)

//2.模块的导出
//导出单个成员
exports.foo = “变量”
exports.add = function()&#123;&#125;

//导出多个成员
module.exports = &#123;
&#125;


#ES6模块化规范
//1.导出
//导出单个成员
export let name = &#39;leo&#39;;
export let age= 30;
let name= &#39;leo&#39;;
let age= 30;
let kk = &quot;abc&quot;
//导出多个成员
export &#123;name, age&#125;;
//导出默认成员
export default kk;

//2.引入
import kk,&#123;name,age&#125; from &#39;a.js&#39;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:26:30.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-49_JavaScript的严格模式"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdp000ar0v98t6yeis5.html">49_JavaScript的严格模式</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>javascript 代码中的”use strict”是使用严格模式，使用严格模式，一些不规范的语法将不再支持。</p>
<pre><code>全局变量显式声明
静态绑定
禁止使用 with 语句
eval 中定义的变量都是局部变量
禁止 this 关键字指向全局对象
禁止在函数内部遍历调用栈
严格模式下无法删除变量。只有 configurable 设置为 true 的对象属性，才能被删除
正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，
将报错。
严格模式下，对一个使用 getter 方法读取的属性进行赋值，会报错。
严格模式下，对禁止扩展的对象添加新属性，会报错。
严格模式下，删除一个不可删除的属性，会报错。
正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，
这属于语法错误。
正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于
语法错误。
正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严
格模式禁止这种表示法，整数第一位为 0，将报错。
不允许对 arguments 赋值
arguments 不再追踪参数的变化
禁止使用 arguments.callee
严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的
代码块内声明函数
严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。


严格模式的一些主要优点包括：
- 使调试更加容易。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。(实时显示错误代码，方便调试)
- 防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。(如果一个变量在没声明就赋值，这个变量会自动变成全局变量，防止意外)
- 消除 this 强制。如果没有严格模式，引用null或未定义的值到 this 值会自动强制到全局变量。这可能会导致许多令人头痛的问题和让人恨不得拔自己头发的bug。在严格模式下，引用 null或未定义的 this 值会抛出错误。
- 不允许重复的属性名称或参数值。当检测到对象（例如，var object = &#123;foo: &quot;bar&quot;, foo: &quot;baz&quot;&#125;;）中重复命名的属性，或检测到函数中（例如，function foo(val1, val2, val1)&#123;&#125;）重复命名的参数时，严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。(避免重复命名，变量，参数，等)
- 使eval() 更安全。在严格模式和非严格模式下，eval() 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在 eval() 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。(eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。)
- 在 delete使用无效时抛出错误。delete操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:24:28.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-48_减低页面加载时间的几种方法"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdo0009r0v9dtsgcq9p.html">48_减低页面加载时间的几种方法</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>1.减少http请求数量和体积
    -压缩 css、js 文件
    -合并 js、css 文件，减少 http 请求
    -使用CSS Sprites图，合并多个CSS图片，合理使用图片压缩
    -合理使用http缓存，减少http请求
    -使用外部的css和js以减少服务器的压力
    
2.css和script的位置
    把 css 样式引入放在&lt;head&gt;标签中，把 &lt;script&gt;资源引入放在&lt;/body&gt;闭合之前。
    外链脚本在加载时却常常阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。所以说尽可能的将脚本往后挪，减少对并发下载的影响
    
3.DOM操作优化
    -要避免在document上直接进行频繁的DOM操作(用innerHTML代替DOM操作)，缓存DOM节点查找的结果
    -使用classname代替大量的内联样式修改
    -对于复杂的UI元素，设置position为absolute或fixed
    -在js动画和css动画之间尽量使用css动画
    -适当使用canvas
    -使用事件代理
    -避免使用eval或Function，每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码，这是很消耗资源的操作 
    -避免大量的字符串拼接，可以使用数组的join方法

4.CSS选择符优化
    -避免使用通配符选择器，避免使用后代选择器
    -选择器匹配是从右向左匹配的，选择器语句链越短，浏览器的匹配速度越快
    -避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作
    -搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）。在写样式时，避免触发重新布局的可能
    -减少使用昂贵的属性，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价。box-shadow/border-radius/filter/透明度/:nth-child等
    -不要使用@import
    -尽量减少css表达式的使用  background-color: expression((new Date()).getHours()%2?&quot;#FFFFFF&quot;: &quot;#000000&quot; );

//附：重排和重绘的操作
-重排的操作：
    width    height    padding    margin
    display    border-width    border    top
    position    font-size    float    text-align
    overflow-y    font-weight    overflow    left
    font-family    line-height    vertical-align    right
    clear    white-space    bottom    min-height
    offsetTop  offsetLeft  offsetWidth   offsetHeight
    scrollTop   scrollLeft  scrollWidth   scrollHeight
    clientTop   clientLeft   clientWidth  clientHeight 
    getComputedStyle()    (currentStyle in IE)
 -重绘的操作：
     color    border-style    visibility    background
    text-decoration    background-image    background-position    background-repeat
    outline-color    outline    outline-style    border-radius
    outline-width    box-shadow    background-size
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:23:02.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-47_前端兼容问题的解决方案"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdq000br0v9a5cjenzy.html">47_前端兼容问题的解决方案</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>1、在 IE 下和火狐下事件冒泡不一样
//阻止冒泡的兼容性写法
function stopBubble(event)&#123;
    var e=arguments.callee.caller.arguments[0]||event;
    if(e&amp;&amp;e.stopPropagation)&#123;
        e.stopPropagation()
    &#125;else if(window.event)&#123;
        //ie
        window.event.cancelBubble=true;
    &#125;
&#125;


//阻止浏览器默认行为的兼容性写法
function stopDefault(event)&#123;
    var e=arguments.callee.caller.arguments[0]||event;
    //阻止默认浏览器动作(W3C)
    if(e&amp;&amp;e.preventDefault)&#123;
        e.preventDefault();
    &#125;else&#123;
        //IE中阻止函数默认动作的方式
        window.event.returnValue=false;      
    &#125;
    return false;
&#125;


2、IE 的写法： tbody=table.childNodes[0]
    在 FF 中，firefox 会在子节点中包含空白则第一个子节点为空白&quot;&quot;， 而 ie 不会返回空白
    可以通过 if(&quot;&quot; != node.nodeName)过滤掉空白子对象

3、模拟点击事件
if(document.all)&#123; //ie 下
    document.getElementById(&quot;a3&quot;).click();
&#125;
else&#123; //非 IE
    var evt = document.createEvent(&quot;MouseEvents&quot;);
    evt.initEvent(&quot;click&quot;, true, true);
    document.getElementById(&quot;a3&quot;).dispatchEvent(evt);
&#125;

4、事件注册
if (isIE)&#123;
   window.attachEvent(&quot;onload&quot;, init);
&#125;else&#123;
   window.addEventListener(&quot;load&quot;, function()&#123;&#125;)

5、ajax对象的获取
   IE： ActiveXObject
   其他浏览器：XMLHttpRequest

6、firstElement等返回结果不一样
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:21:19.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-46_js延迟加载的方式有哪些"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdn0008r0v9770t0w5s.html">46_js延迟加载的方式有哪些</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <ol>
<li><p>defer 和 async :    js文件的加载不会堵塞DOM的解析</p>
<pre><code>1. defer 属性
&lt;script  src=&quot;file.js&quot; defer&gt;&lt;/script&gt; 
defer属性声明这个脚本中将不会有 document.write 或 dom 修改。
浏览器将会并行下载 file.js 和其它有 defer 属性的script，而不会阻塞页面后续处理。
 
defer属性在IE 4.0中就实现了，超过13年了！Firefox 从 3.5 开始支持defer属性 。
注：所有的defer 脚本保证是按顺序依次执行的。

2. async 属性
&lt;script src=&quot;file1.js&quot; async&gt;&lt;/script&gt; 
async属性是HTML5新增的。作用和defer类似，但是它将在下载后尽快执行，不能保证脚本会按顺序执行。它们将在onload 事件之前完成。
Firefox 3.6、Opera 10.5、IE 9 和 最新的Chrome 和 Safari 都支持 async 属性。可以同时使用 async 和 defer，这样IE 4之后的所有 IE 都支持异步加载。
</code></pre>
</li>
<li><p>动态创建 DOM 方式（创建 script，插入到 DOM 中，加载完毕后 callBack）</p>
<pre><code>var ga = document.createElement(&#39;script&#39;);
ga.type = &#39;text/javascript&#39;;
ga.async = true;
ga.src = &#39;xxxx&#39;;
var s = document.getElementsByTagName(&#39;script&#39;)[0];
s.parentNode.insertBefore(ga, s);
</code></pre>
</li>
<li><p>由于JavaScript的动态性，还有很多异步加载方法： XHR Injection、 XHR Eval、 Script In Iframe</p>
</li>
</ol>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:17:52.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-45_iframe的优缺点"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdl0006r0v9bquc82nb.html">45_iframe的优缺点</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>iframe的优点：
1.iframe能够原封不动的把嵌入的网页展现出来，iframe和主页面是并行加载的
2.如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。
3.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。
4.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。

iframe的缺点：
1.会产生很多页面，不容易管理。
2.iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。
3.代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。
4.很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。
5.iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。 分析了这么多，现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。
6.iframe会堵塞主页面的onload事件
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:15:54.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-44_创建函数的几种方式"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdl0007r0v92tyedjar.html">44_创建函数的几种方式</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>第一种（函数声明）：
function sum1(num1,num2)&#123;
    return num1+num2;
&#125;

第二种（函数表达式）：
var sum2 = function(num1,num2)&#123;
    return num1+num2;
&#125;

第三种(匿名函数)：
function()&#123;&#125;:只能自己执行自己

第四种(new Function创建函数)
let str = &#39;return &#39; + &#39;`Hello $&#123;name&#125;!`&#39;;
let func = new Function(&#39;name&#39;, str);
func(&#39;Jack&#39;) // &quot;Hello Jack!&quot;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:14:23.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-43_javascript继承的方法"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdk0005r0v9anio32tj.html">43_javascript继承的方法</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>1.借助构造函数实现继承</p>
<pre><code>   //  定义父类
    function Parent1 () &#123;
        this.name = &#39;xxx&#39;,
        this.age = 18
    &#125;
    //  定义子类
    function Child1 () &#123;
        //通过call()方法改变Child1的this指向使子类的函数体内执行父级的构造函数从而实现继承效果
        Parent1.call(this)
        this.address = &#39;yyy&#39;
    &#125;
    //  构建子类的实例s1
    var s1 = new Child1()
    console.log(s1.name)  //xxx
    缺点:该方法的实力(s1)无法使用父类(Parent1)的原型(prototype)中的属性和方法
    
</code></pre>
<p>2.借助原型链实现继承</p>
<pre><code> function Parent2 () &#123;
        this.name = &#39;xx&#39;,
        this.age = 19,
        this.play = [1,2,3]
    &#125;
    //  一样在父类添加say方法
    Parent2.prototype = &#123;
        say () &#123;
            console.log(&#39;say&#39;)
        &#125;
    &#125;
    function Child2 (address) &#123;
        this.address = &#39;yyy&#39;
    &#125;
    // 让子类的原型直接指向父类实例
    Child2.prototype = new Parent2()
    //  生成两个子类的实例s2、s3
    var s2 = new Child2()
    var s3 = new Child2()
    // s2实例继承了父类中的name属性
    console.log(s2.name)  //xx
    //  s2实例也同样继承了父类原型上的say方法
    console.log(s2.say())  //say
    缺点:在子类调用构造函数创建对象的时候，无法入参所有的属性值
</code></pre>
<p>3.组合继承</p>
<pre><code>   function Parent5 () &#123;
        this.name = &#39;xx&#39;,
        this.age = 20,
        this.play = [4,5,6]
    &#125;
    function Child5 (name,age,address) &#123;
        Parent5.call(this,name,age)
        this.address = address
    &#125;
    // 比较关键的一步
    Child5.prototype = new Parent5()
    var c = new Child5(&quot;zhangsan&quot;,19,&quot;无锡&quot;)
</code></pre>
<p>4.实例继承(为父类实例添加新特性，作为子类实例返回)</p>
<pre><code>  function Animal (name) &#123;
      // 属性
      this.name = name || &#39;Animal&#39;;
      // 实例方法
      this.sleep = function()&#123;
        console.log(this.name + &#39;正在睡觉！&#39;);
      &#125;
    &#125;
    // 原型方法
    Animal.prototype.eat = function(food) &#123;
      console.log(this.name + &#39;正在吃：&#39; + food);
    &#125;;

function Cat()&#123;
  var instance = new Animal();
  instance.name = name || &#39;Tom&#39;;
  return instance;
&#125;
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // false
</code></pre>
<p>5.拷贝继承</p>
<pre><code>   // 定义一个动物类
    function Animal (name) &#123;
      // 属性
      this.name = name || &#39;Animal&#39;;
      // 实例方法
      this.sleep = function()&#123;
        console.log(this.name + &#39;正在睡觉！&#39;);
      &#125;
    &#125;
    // 原型方法
    Animal.prototype.eat = function(food) &#123;
      console.log(this.name + &#39;正在吃：&#39; + food);
    &#125;;
    function Cat(name)&#123;
      var animal = new Animal();
     // 遍历拷贝属性
      for(var p in animal)&#123;
        Cat.prototype[p] = animal[p];
      &#125;
      Cat.prototype.name = name || &#39;Tom&#39;;
    &#125;

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:11:07.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-42_移动端兼容"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdj0004r0v9g4fgdgm6.html">42_移动端兼容</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>bootstrap中起步中有：</p>
<p>1&gt;ios移动端click事件300ms的延迟响应. 用fastclick来解决</p>
<p>2&gt;zepto的touch模块的tap事件有点透的问题，也是用fastclick来解决</p>
<p>3&gt;一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发，css增加cursor:pointer就搞定了</p>
<p>4&gt;ios下取消input在输入的时候英文首字母的默认大写</p>
<pre><code>&lt;input autocapitalize=&quot;off&quot;autocorrect=&quot;off&quot; /&gt;
</code></pre>
<p>5&gt;fixed定位缺陷</p>
<pre><code>ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位
android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位
ios4下不支持position:fixed

解决方案： 可用iScroll插件解决这个问题
</code></pre>
<p>6&gt;Input 的placeholder会出现文本位置偏上的情况</p>
<pre><code>input 的placeholder会出现文本位置偏上的情况：PC端设置line-height等于height能够对齐，而移动端仍然是偏上，解决是设置line-height：normal
</code></pre>
<p>7&gt;calc的兼容性处理</p>
<pre><code> CSS3中的calc变量在iOS6浏览器中必须加-webkit-前缀，目前的FF浏览器已经无需-moz-前缀。
 Android浏览器目前仍然不支持calc，所以要在之前增加一个保守尺寸：

div &#123;
    width: 95%;
    width: -webkit-calc(100% - 50px);
    width: calc(100% - 50px);
&#125;
</code></pre>
<p>8&gt;在移动端修改难看的点击的高亮效果，iOS和安卓下都有效：</p>
<pre><code>\ &#123;-webkit-tap-highlight-color:rgba(0,0,0,0);&#125;
</code></pre>
<p>9&gt;阻止旋转屏幕时自动调整字体大小</p>
<pre><code>html, body, form, fieldset, p, div, h1, h2, h3, h4, h5,h6 &#123;-webkit-text-size-adjust:none;&#125;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:09:49.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  

  
    <nav class="pagination">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next</a>
    </nav>
  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/" rel="tag">js的基本数据类型和引用数据类型详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8Enode%E5%90%8E%E7%AB%AF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="tag">mongodb的安装、使用，与node后端连接，前端的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%80%E4%B9%88%E6%98%AFMVVM%EF%BC%8CMVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E4%BB%A5%E5%8F%8A%E4%B8%8EMVC%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">什么是MVVM，MVVM模式的优点以及与MVC模式的区别</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E4%B8%89%E8%80%85%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86/" rel="tag">对三者的声明方式进行区分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E3%80%81%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">对象的引用、浅拷贝、深拷贝在内存中的实现过程、三者的区别</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/ckzkw1mmm000098v96qneg6ml.html">51_es6常用语法</a>
          </li>
        
          <li>
            <a href="/ckzkvyzdq000cr0v92yrj72oj.html">50_js模块化规范</a>
          </li>
        
          <li>
            <a href="/ckzkvyzdp000ar0v98t6yeis5.html">49_JavaScript的严格模式</a>
          </li>
        
          <li>
            <a href="/ckzkvyzdo0009r0v9dtsgcq9p.html">48_减低页面加载时间的几种方法</a>
          </li>
        
          <li>
            <a href="/ckzkvyzdq000br0v9a5cjenzy.html">47_前端兼容问题的解决方案</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <div class="footer-wrap">
        <div class="footer-inner"> 
            小豆子的博客 &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1630473019367.js"></script>


<script src="/dist/custom.js?1630473019367.js"></script>









</body>

</html>