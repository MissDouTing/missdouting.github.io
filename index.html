<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>小豆子的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1630473019367.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="MissDou">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>小豆子的博客</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-09_mongodb数据库使用流程"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckz0tqj9l0000mcv968j96rzy.html">09_mongodb数据库使用流程</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>使用mongodb数据库的方式</p>
<h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a><strong>安装</strong>：</h2><p>在<a target="_blank" rel="noopener" href="https://www.mongodb.org/dl/win32%E7%BD%91%E5%9D%80%E4%B8%AD%E4%B8%8B%E8%BD%BD64%E4%BD%8Dmongodb%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E6%9C%AC%E6%9C%BA%E6%98%AF64%E4%BD%8D%E7%94%B5%E8%84%91%EF%BC%8C%E5%9C%A8%E6%AD%A4%E7%BD%91%E5%9D%80%E4%B8%AD%E4%B8%8B%E8%BD%BD%E5%8D%B3%E5%8F%AF%EF%BC%89">https://www.mongodb.org/dl/win32网址中下载64位mongodb数据库（本机是64位电脑，在此网址中下载即可）</a></p>
<p>在<a target="_blank" rel="noopener" href="https://www.mongodb.org/dl/win32/i386%E7%BD%91%E5%9D%80%E4%B8%AD%E4%B8%8B%E8%BD%BD32%E4%BD%8Dmongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%82">https://www.mongodb.org/dl/win32/i386网址中下载32位mongodb数据库。</a></p>
<p>下载完成后，双击进行安装，按提示点击即可。（注意下图中的默认选项取消，否则会下载的非常慢！原因是他会在中途帮你下载推荐的东西）</p>
<img src="imgs/2022.01.30/图片1.png">

<p>注意：安装完成后在电脑上找不到这个软件图标。启动方式是通过cmd命令行进行启动。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用:"></a><strong>使用:</strong></h2><h3 id="一、启动mongodb数据库。"><a href="#一、启动mongodb数据库。" class="headerlink" title="一、启动mongodb数据库。"></a><strong>一、启动mongodb数据库。</strong></h3><p>在cmd中输入命令<code>mongod</code>回车，看到 waiting for connections on port 27017表示mongodb数据库启动成功，等待连接。注意这个cmd命令行窗口不能关闭，否则会关闭mongobd数据库。</p>
<h3 id="二、客户端连接mongodb数据库。"><a href="#二、客户端连接mongodb数据库。" class="headerlink" title="二、客户端连接mongodb数据库。"></a><strong>二、客户端连接mongodb数据库。</strong></h3><p>连接mongodb数据库有两种方式：</p>
<p>方法一：再打开一个cmd窗口，输入<code>mongo</code>命令（连接上数据库），输入<code>show dbs;</code>命令（查看有几个数据库）</p>
<p>方法二：使用mongodb客户端软件（注意：因为方法一通过输入命令操作数据库比较麻烦，本文使用方法二）。打开mongdb客户端软件，点击connect按钮进行配置，使mongodb客户端连接上mongodb数据库。（不用改动任何配置，使用默认即可，mongodb数据库的端口号是27017）</p>
<h3 id="三、客户端操作mongodb数据库。"><a href="#三、客户端操作mongodb数据库。" class="headerlink" title="三、客户端操作mongodb数据库。"></a><strong>三、客户端操作mongodb数据库。</strong></h3><h4 id="1-客户端常用命令"><a href="#1-客户端常用命令" class="headerlink" title="1.客户端常用命令"></a><strong>1.客户端常用命令</strong></h4><p>然后在该mongodb客户端软件中输入相关命令进行填写数据库。常用的命令如下：</p>
<pre><code>// 删除当前使用数据库
db.dropDatabase();   

//创建youshi数据库（创建后不会显示，必须有数据填入才能显示该数据库）
use youshi

// 向youshi数据库里的student集合下插入一条数据
db.student.insert(&#123;id:1,name:&quot;花仙子&quot;&#125;)

// 查看student集合下的所有数据
db.student.find()

// 删除student集合
db.student.drop();

db.dou_ting_ting.drop();

db.dou_ting_tings.find()

//删除集合下的数据 
db.dou_ting_tings.remove(&#123;&#125;)
</code></pre>
<h4 id="2-批量插入数据库的方法"><a href="#2-批量插入数据库的方法" class="headerlink" title="2.批量插入数据库的方法"></a><strong>2.批量插入数据库的方法</strong></h4><p>1.例如通过记事本方式导入，把该写入数据的记事本放在桌面或者你需要放入的位置（记住路径）</p>
<img src="imgs/2022.01.30/图片2.png">

<p>打开新的cmd命令行，输入命令<code>mongoimport -d igeek -c student ./student.txt</code>（也就是mongoimport -d 数据库名字 -c 集合的名字 文件名 -d参数表示需要往哪个数据库导入数据，-c参数表示需要往哪个集合（表）中导入数据）</p>
<p>2.数据库导入成功，在mongodb客户端查看。（如何查看mongodb数据库都有哪些命令？在c盘/Program Files/MongoDB/Server/4.0/bin中文件名，去掉后缀，即是mongodb数据库的命令）</p>
<h3 id="四、Vscode连接数据库。"><a href="#四、Vscode连接数据库。" class="headerlink" title="四、Vscode连接数据库。"></a><strong>四、Vscode连接数据库。</strong></h3><p>然后在vscode中进行连接mongodb数据库，使后台能够操作数据库。</p>
<p>1.首先对vscode的文件夹进行一系列初始化操作（详情请看我的另外一篇文章）。</p>
<p>这里以node的express后台连接数据库为例：在vscode从终端打开中输入命令<code>npm init -y</code>出现package.json文件 ， <code>npm install express</code>出现node_modules文件夹，建立app.js文件，在app.js文件中输入 </p>
<img src="imgs/2022.01.30/图片3.png">

<p>初始化操作完毕。</p>
<p>2.安装mongoose。在vscode中输入命令<code>npm install mongoose</code>（用node安装mongoose），这样能在后台能够通过node的mongoose去连接数据库。</p>
<p>3.在app.js中引入mongoose。</p>
<img src="imgs/2022.01.30/图片4.png">

<p>4.使用mongoose连接数据库。</p>
<img src="imgs/2022.01.30/图片5.png">

<p>5.输入命令<code>nodemon app.js</code>，显示“连接成功”说明数据库已经连接到后台了。</p>
<h3 id="五、vscode操作数据库。"><a href="#五、vscode操作数据库。" class="headerlink" title="五、vscode操作数据库。"></a><strong>五、vscode操作数据库。</strong></h3><h4 id="1-后端操作数据库"><a href="#1-后端操作数据库" class="headerlink" title="1.后端操作数据库"></a><strong>1.后端操作数据库</strong></h4><p>1.在app.js中声明一个Scheme</p>
<img src="imgs/2022.01.30/图片6.png">

<p>2.在app.js中创建Model</p>
<img src="imgs/2022.01.30/图片7.png">

<p>3.在app.js中写接口并且向数据库的animal集合中插入数据</p>
<img src="imgs/2022.01.30/图片8.png">

<p>测试该接口是否能用，在浏览器中输入localhost:8000/save，显示“保存数据成功”，说明接口创建成功。</p>
<p>补充：req为从浏览器获取数据，res为向浏览器发送数据。req.body()方法为后台从前台获取数据，res.send()方法为后台向前台发送数据。集合名.find()方法为在数据库中查找对应的条件，集合名.save()方法为保存到数据库，集合名.remove()方法为删除数据库中的数据。new 集合/对象名()为新建一个集合/对象（在数据库中叫集合，在代码中叫对象）。</p>
<p>4.打开mongodb客户端软件，刷新数据库，发现igeek数据库中原本只有student集合，现在多了个animals集合。（注意接口中写的是animal集合对应的就是animals集合，会多个s，记住必须是带s的，自己导入的数据库也得带s）</p>
<p>5.后端连接数据库完毕。</p>
<h4 id="2-优化"><a href="#2-优化" class="headerlink" title="2.优化"></a><strong>2.优化</strong></h4><p>1.在vscode中输入命令<code>npm i art-template express-art-template</code></p>
<p>2.把下面代码注释掉</p>
<img src="imgs/2022.01.30/图片9.png">

<p>3.新建一个views文件夹，并在views里新建一个student.html文件。</p>
<img src="imgs/2022.01.30/图片10.png">

<p>4.在app.js中配置art-template</p>
<img src="imgs/2022.01.30/图片11.png">

<p>5.写接口</p>
<img src="imgs/2022.01.30/图片12.png">

<p>输入命令<code>Nodemon app.js</code>启动端口</p>
<p>在浏览器中输入localhost:8000/student，显示“学生列表页面”表示写接口成功。</p>
<p>6.建立router文件夹，在router文件夹中建立student.js文件。写入代码</p>
<img src="imgs/2022.01.30/图片13.png">

<p>并把上一步在app.js中写的/student接口去掉。</p>
<p>7.在app.js中写入。这样我们就把接口写在router文件夹里去了。</p>
<img src="imgs/2022.01.30/图片14.png">

<p>8.连数据库查数据。创建一个models文件夹（放所有和数据相关的代码），在models文件夹中建立student.js文件。写入如下代码</p>
<img src="imgs/2022.01.30/图片15.png">

<p>9.在接口中查数据。也就是在router/student.js中查数据</p>
<img src="imgs/2022.01.30/图片16.png">

<p>补充：</p>
<img src="imgs/2022.01.30/图片17.png">

<p>10.后端重构完成</p>
<h4 id="3-前端使用数据库"><a href="#3-前端使用数据库" class="headerlink" title="3.前端使用数据库"></a><strong>3.前端使用数据库</strong></h4><p>1.在前台页面渲染数据。</p>
<p>在views/student.html中写入代码：</p>
<img src="imgs/2022.01.30/图片18.png">

<img src="imgs/2022.01.30/图片19.png">

<img src="imgs/2022.01.30/图片20.png">

<p>显示效果如下：</p>
<img src="imgs/2022.01.30/图片21.png">

<p>表单已经有了，需要提交给后台，因为form表单提交用的post请求，则后台需要有接口，并且是post请求。</p>
<p>2.写post接口：在router/student.js中写入</p>
<img src="imgs/2022.01.30/图片22.png">

<p>3.如何从post请求获取参数？安装body-parser，输入命令<code>npm install body-parser</code></p>
<p>在app.js中引入body-parser，并配置</p>
<img src="imgs/2022.01.30/图片23.png">

<p>然后重启接口，输入命令<code>nodemon app.js</code></p>
<p>4.在router/student.js中写入</p>
<img src="imgs/2022.01.30/图片24.png">

<img src="imgs/2022.01.30/图片25.png">

<p>5.把数据保存到数据库：</p>
<img src="imgs/2022.01.30/图片26.png">

<p>6.结束。</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-01-30T04:44:01.000Z" itemprop="datePublished">2022-01-30</time>
</div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mongodb%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8Enode%E5%90%8E%E7%AB%AF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="tag">mongodb的安装、使用，与node后端连接，前端的使用</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-08_js经典输出顺序问题"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckwvnv7iz0000l8v934zt8fgu.html">08_js经典输出顺序问题</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>分析下面代码：</p>
<pre><code class="javascript">&lt;script&gt;
    console.log(11);
    setTimeout(function()&#123;
        console.log(22);
    &#125;)
    // Promise所入参的函数是立马执行的
    new Promise(function(resolve)&#123;
        console.log(33);
        resolve();
        console.log(44);
    &#125;)
    // Promise的then是在resolve和reject后执行的
    .then(function()&#123;
        console.log(55);
    &#125;)
    new Promise(function(resolve)&#123;
        resolve()
    &#125;)
    .then(function()&#123;
        console.log(77);
    &#125;)
    console.log(66);
    // 打印顺序是  11  33  44  66  55  77  22
&lt;/script&gt;
</code></pre>
<p>分析：</p>
<img src="imgs/2021.12.07/图片1.png">

<p>整个script代码会先进入主栈，从上向下运行，则先<strong>打印11</strong></p>
<img src="imgs/2021.12.07/图片2.png">

<p>然后是setTimeout定时器会放在线程里（这里不考虑线程，只需知道线程处理完后都会交给队列），由于定时器没有设置时间，然后会进入宏任务队列。然后是Promise，Promise所入参的函数立马执行，则会<strong>打印33</strong>，这里有resolve，一resolve这个then会立马执行，Promise的then会进入微任务队列，Promise里还剩下一个44，所以在主栈中<strong>打印44</strong>。然后还是一个Promise，Promise里没有打印，Promise的then会进入微任务队列，接着<strong>打印66</strong>。</p>
<img src="imgs/2021.12.07/图片3.png">

<p>主栈所有任务执行完毕，主栈清空，主栈清空后，会到任务队列拿任务执行，先把微任务队列的所有任务拿到主栈执行，根据队列的先进先出原则，会先拿微任务队列的55到主栈，<strong>55执行完毕</strong>，主栈清空，接着拿微任务队列的77,<strong>77执行完毕</strong>，主栈清空。</p>
<img src="imgs/2021.12.07/图片4.png">

<img src="imgs/2021.12.07/图片5.png">

<img src="imgs/2021.12.07/图片6.png">

<p>然后去宏任务队列拿任务22到主栈，<strong>22执行完毕</strong>，主栈清空，所有任务执行完毕。</p>
<blockquote>
<p>总结：默认情况下，script整个代码块会入主栈执行，当遇到setTimeout，setInterval等代码块的时候会入宏任务队列，当遇到process.nextTick，Promise.then的时候会入微任务队列，当主栈执行完整个script代码块的时候，会先从微任务队列把所有的微任务放到主栈执行（遵循先进先出原则），当微任务队列的所有任务清空后，再从宏任务队列拿一个任务到主栈执行，然后依次反复。</p>
</blockquote>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-12-07T05:03:48.000Z" itemprop="datePublished">2021-12-07</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-07_对象的引用、浅拷贝、深拷贝"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckwstx9ps0000mwv9ew0l4cy0.html">07_对象的引用、浅拷贝、深拷贝</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>本文是对对象在内存中的三种表现形式进行讲解：</p>
<h2 id="1-对象的引用赋值："><a href="#1-对象的引用赋值：" class="headerlink" title="1.对象的引用赋值："></a>1.对象的引用赋值：</h2><p>对象是引用类型，引用类型在不同的编程语言中叫法不同，在c语言、c++中引用类型叫指针，在java、javaScript语言中叫引用类型。（本文以javaScript语言为例）</p>
<pre><code>&lt;script&gt;
    const info = &#123;name:&quot;yoyo&quot;,age:18&#125;;
    const obj = info;
    info.name = &quot;kobe&quot;;
    console.log(obj.name);//kobe
&lt;/script&gt;
</code></pre>
<p>在内存中的表现：</p>
<p>首先<code>const info = &#123;name :&quot;yoyo&quot; , age: 18&#125;;</code>在内存中实现：</p>
<p>info是对象，一旦是对象，就会在堆内存里创建一个空间，用来存放对象里的相关内容。栈里放的是这块空间的地址，比如0x100（一般内存地址都是16进制，则以0x开头）</p>
<img src="imgs/2021.12.05/图片1.png">

<img src="imgs/2021.12.05/图片2.png">

<p>若此时<code>const obj = info</code>，则在内存中的表现为：取出info的内存地址0x100，然后把该内存地址赋值给obj。</p>
<img src="imgs/2021.12.05/图片3.png">

<img src="imgs/2021.12.05/图片4.png">

<p>若此时<code>info.name=&quot;kabe&quot;</code>，则意味着0x100.name=”kobe”</p>
<img src="imgs/2021.12.05/图片5.png">

<img src="imgs/2021.12.05/图片6.png">

<p>此时打印<code>console.log(obj.name)</code>，结果为kobe，因为obj和info指向的同一个对象。</p>
<p><strong>为什么叫对象的引用赋值？因为这个案例仅是把info对象的引用（地址）赋值给了obj</strong>。</p>
<h2 id="2-对象的浅拷贝"><a href="#2-对象的浅拷贝" class="headerlink" title="2.对象的浅拷贝"></a>2.对象的浅拷贝</h2><h3 id="第一种类型："><a href="#第一种类型：" class="headerlink" title="第一种类型："></a>第一种类型：</h3><pre><code>&lt;script&gt;
    const info = &#123;name:&quot;yoyo&quot;,age:18&#125;;
    //assign方法会把info对象的所有属性拷贝一份放&#123;&#125;里，然后作为返回值返回给obj
    //浅拷贝的方法有很多，我这里选择assign方法做演示
    const obj = Object.assign(&#123;&#125;,info);
    info.name = &quot;kobe&quot;;
    console.log(obj.name)   //yoyo
&lt;/script&gt;
</code></pre>
<p>在内存中的表现：</p>
<p><code>const info = &#123;name :&quot;yoyo&quot; , age: 18&#125;;</code>在内存中的实现过程上面已展示。</p>
<p><code>const obj = Object.assign(&#123;&#125;,info);</code>在内存中的实现过程</p>
<img src="imgs/2021.12.05/图片7.png">

<img src="imgs/2021.12.05/图片8.png">

<p>若此时<code>info.name = &quot;kobe&quot;</code>，改变的是info对象的name，而不是拷贝后对象的name。</p>
<img src="imgs/2021.12.05/图片9.png">

<img src="imgs/2021.12.05/图片10.png">

<p>打印<code>console.log(obj.name)</code>结果为yoyo，因为他们指向的不是同一个对象。</p>
<h3 id="第二种类型："><a href="#第二种类型：" class="headerlink" title="第二种类型："></a>第二种类型：</h3><pre><code>&lt;script&gt;
    const info = &#123;name:&quot;yoyo&quot;,age:18,friend:&#123;name:&quot;kobe&quot;,height:1.80&#125;&#125;;
    //assign方法会把info对象的所有属性拷贝一份放&#123;&#125;里，然后作为返回值返回给obj
    //浅拷贝的方法有很多，我这里选择assign方法做演示
    const obj = Object.assign(&#123;&#125;,info);
    info.friend.name = &quot;jame&quot;;
    console.log(obj.frend.name)   //jame
&lt;/script&gt;
</code></pre>
<p>在内存中的表现：</p>
<p><code>const info = &#123;name:&quot;yoyo&quot;,age:18,friend:&#123;name:&quot;kobe&quot;,height:1.80&#125;&#125;;</code>在内存中的实现过程</p>
<img src="imgs/2021.12.05/图片11.png">

<img src="imgs/2021.12.05/图片12.png">

<p><code>const obj = Object.assign(&#123;&#125;,info);</code>在内存中的实现过程</p>
<img src="imgs/2021.12.05/图片13.png">

<img src="imgs/2021.12.05/图片14.png">

<p><code>info.friend.name = &quot;jame&quot;;</code>在内存中的实现过程</p>
<img src="imgs/2021.12.05/图片15.png">

<img src="imgs/2021.12.05/图片16.png">

<p>打印<code>console.log(obj.frend.name)</code>结果为jame，原因是：虽然不是指向的同一个对象，但是不同对象里的对象是同一个。</p>
<h2 id="3-对象的深拷贝"><a href="#3-对象的深拷贝" class="headerlink" title="3.对象的深拷贝"></a>3.对象的深拷贝</h2><pre><code>&lt;script&gt;
    const info = &#123;name:&quot;yoyo&quot;,age:18,friend:&#123;name:&quot;kobe&quot;,height:1.80&#125;&#125;;
    //JSOn.stringify方法把对象转化为字符串
    //JSON.parse方法把字符串转化为对象（也就是还原），还原时会在内存中生成新的对象，和原来对象没有任何关系
    const obj = JSON.parse(JSON.stringify(info));
    info.friend.name = &quot;jame&quot;;
    console.log(obj.friend.name);//kobe
&lt;/script&gt;
</code></pre>
<p>上述借助了JSON方法对对象做了深拷贝，深拷贝后的对象和原先的对象没有任何关系，也就是对象里的所有内容都会拷贝一份新的，包括对象里的对象。（这里就不再重复画图了，原理一样，下面是关键步骤图）</p>
<img src="imgs/2021.12.05/图片17.png">

<img src="imgs/2021.12.05/图片18.png">

<p>深拷贝实现还有其他方法，比如借助lodash第三方库，（用法是在js中先引入，再使用对应的方法）</p>
<pre><code>&lt;script&gt;
    const info = &#123;name:&quot;yoyo&quot;,age:18,friend:&#123;name:&quot;kobe&quot;,height:1.80&#125;&#125;;
    //使用lodash库的方法进行深拷贝
    const obj = _.cloneDeep(info);
    info.friend.name = &quot;jame&quot;;
    console.log(obj.friend.name);//kobe
&lt;/script&gt;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-12-05T05:16:30.000Z" itemprop="datePublished">2021-12-05</time>
</div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E3%80%81%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">对象的引用、浅拷贝、深拷贝在内存中的实现过程、三者的区别</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-06_js基本类型和引用类型"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckwstwhy100008ov97drxan3v.html">06_js基本类型和引用类型</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="js数据类型的种类"><a href="#js数据类型的种类" class="headerlink" title="js数据类型的种类"></a>js数据类型的种类</h2><p>js的数据类型分为两种：基本数据类型和引用数据类型（也叫对象类型）</p>
<p>js的数据类型分为两种：基本数据类型和引用数据类型（也叫对象类型）</p>
<ul>
<li><p>常用的js基础数据类型有number, string, boolean, null, underfined</p>
</li>
<li><p>js引用数据类型有object,array,function,data等（除基本数据类型外都是引用数据类型）</p>
</li>
</ul>
<h2 id="基本数据类型详解"><a href="#基本数据类型详解" class="headerlink" title="基本数据类型详解"></a>基本数据类型详解</h2><p>1.number类型。数字类型（整数和小数）</p>
<p>2.string类型。字符串类型（通过单引号或者是双引号括起来的值）</p>
<p>3.boolean类型。布尔类型（值只有两个：true和false）</p>
<p>4.null类型。空类型（有值，但是不知道值属于什么数据类型，无法辨认。比如：number类型+boolean类型形成的值，这个值就是null）</p>
<p>5.undefined类型。未定义数据类型（无值，因为没有值，所以不知道值的数据类型，js是通过值来判断数据类型的。比如：变量声明好了，但是没有赋值，这个值就是undefined）</p>
<h2 id="引用数据类型详解"><a href="#引用数据类型详解" class="headerlink" title="引用数据类型详解"></a>引用数据类型详解</h2><p>1.object类型。对象类型（javaScript中所有对象的顶级父元素）</p>
<p>2.array类型。数组类型</p>
<p>3.function类型。函数类型（每个函数都是function类型的实例）</p>
<p>4.data类型。数据类型（通过new Date()来定义Date对象）</p>
<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><ul>
<li><p>基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。</p>
</li>
<li><p>js的引用数据类型是保存在堆内存中的对象，与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。</p>
</li>
<li><p>引用数据类型具有属性和方法，基本数据类型没有。</p>
</li>
</ul>
<img src="imgs/2021.11.25/图片1.png">


        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-11-25T08:10:01.000Z" itemprop="datePublished">2021-11-25</time>
</div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/" rel="tag">js的基本数据类型和引用数据类型详解</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-05_封装一个随机颜色"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckweotwk10000r0v99zsa8chl.html">05_封装一个随机颜色</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code class="javas"> getRandonColor() &#123;
      var r = parseInt(Math.random() * 255);
      var g = parseInt(Math.random() * 255);
      var b = parseInt(Math.random() * 255);
      return `rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`;
    &#125;
</code></pre>
<p><em>parseInt() 函数可解析一个字符串，并返回一个整数。</em></p>
<p>parseInt(string, radix)中有两个参数：string和radix。string是要被解析的字符串，radix是可选的，表示要解析的数字的基数，该值介于2~36之间。</p>
<p>当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p>
<p>当没有设置该参数 radix , JavaScript 默认数字的基数如下:</p>
<ol>
<li>如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。</li>
<li>如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。</li>
<li>如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。</li>
</ol>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>parseInt前面不要加任何东西，我之前写的时候在parseInt前加了个Math.造成报错，parseInt不是Math的方法。</p>
<h3 id="小知识："><a href="#小知识：" class="headerlink" title="小知识："></a>小知识：</h3><p>不同的数据类型在console打印的颜色是不一样的。Number类型的数据是蓝色、Boolean类型的数据是紫红色，Null和Undefined的颜色是灰色，Array类型的数据带中括号，Object类型的数据带大括号。</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-11-13T07:41:53.000Z" itemprop="datePublished">2021-11-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-04_vscode的几种打开方式及区别"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckuo5p5po0000s8v93auf9ytg.html">04_vscode的几种打开方式及区别</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="在vscode中如何打开网页"><a href="#在vscode中如何打开网页" class="headerlink" title="在vscode中如何打开网页"></a>在vscode中如何打开网页</h2><p>方式一： 右键网页，点击open with live server</p>
<p>方式二：右键网页，点击open with default browser</p>
<p>方式三： 开启node服务器，配置静态资源目录，手动打开浏览器，输入指定网址直接访问对应的页面</p>
<p>方式四：开启node服务器，安装express-art-template，写api接口，在api接口中通过res.render方法渲染页面，打开浏览器，输入网址访问对应的接口。</p>
<h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><p>方式一，vscode会给我们开启一个静态服务器（使用的协议是http，仅是个静态服务器，不像node服务器，有node服务器的若干功能），在服务器中显示该网页（使用端口是5500），这种方式一般只出现在写html，css，原生js，jquery中时使用，node之后基本不会再使用这种方式。</p>
<p>方式二：这种方式没有服务器，是通过file协议直接打开网页。这种方式和右击文件后点击在文件资源管理器中显示，然后点击网页打开的方式一样。就相当于直接打开本地磁盘的文件，这种方式几乎不用，因为这种方式不支持c3的媒体查询（c3的媒体查询是@media ）。</p>
<img src="imgs/2021.10.12/图片1.png">
方式三：相当于前后端分离的开发模式，可以在静态资源的网页中去写ajax请求，去发请求拿数据，没有在app.js（后端）里渲染页面。

<img src="imgs/2021.10.12/图片2.png">

<p>方式四： 相当于纯后端渲染的开发模式。</p>
<p> （PS：方式一和方式二如果没有，说明没有装对应的插件）</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-10-12T13:58:04.000Z" itemprop="datePublished">2021-10-12</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-03_node的使用方法"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckumountd0000bwv92b8h4784.html">03_node的使用方法</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="如何用npm去安装工具包？"><a href="#如何用npm去安装工具包？" class="headerlink" title="如何用npm去安装工具包？"></a>如何用npm去安装工具包？</h2><p>1.可以在cmd中使用npm对要下载的工具包进行全局安装，如命令npm install hexo-cli -g（该命令是对hexo包进行全局安装）</p>
<p>2.也可以在vscode中对文件右击从终端打开，使用npm对要下载的工具包进行全局安装，或者仅对建立的文件进行局部安装，如命令npm install express（该命令是对express包进行局部安装）。</p>
<p>这里的从终端打开，有两种终端方式：一是powershell终端。在文件夹中按住shift键右击空白区，出现在此处打开powershell窗口，这是powershell在文件中的打开方式，而在vscode中打开powershell需要配置settings，设置–搜索框中输入settings–点击“在settings.json中编辑”–以json格式输入对应的设置powershell的代码。而是cmd终端。在桌面win+r，输入cmd，出现cmd窗口，这是cmd在电脑中的打开方式，而在vscode中打开cmd也需要配置settings，设置–搜索框中输入settings–点击“在settings.json中编辑”–以json格式输入对应的设置cmd的代码。如下图所示</p>
<img src="imgs/2021.10.11.2/图片1.png">
如何看vscode中的终端设置的是哪个终端？在vscode从终端打开后，终端窗口的右边显示powershell或者cmd。如下图所示

<img src="imgs/2021.10.11.2/图片2.png">

<h2 id="vscode安装工具包及使用步骤："><a href="#vscode安装工具包及使用步骤：" class="headerlink" title="vscode安装工具包及使用步骤："></a>vscode安装工具包及使用步骤：</h2><p>1.在vscode中，先建立一个空文件（注意文件名不要和工具包名一样）。</p>
<p>2.把这个文件从终端打开，输入命令npm init -y（init是启动的意思，注意这个是使用的node，需要先在cmd中全局安装node，才可以在vscode中使用node和npm的命令），空文件夹下会自动出现package.json文件。</p>
<img src="imgs/2021.10.11.2/图片3.png">

<p>3.继续输入命令npm install 包名 –save ，如npm install express –save（这是安装express包的命令），下图是输入npm install express –save命令例子</p>
<img src="imgs/2021.10.11.2/图片4.png">

<p>4.安装完成，之后就可以根据你安装的工具包的官网，去查文档使用你的工具包了。</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-10-11T12:57:11.000Z" itemprop="datePublished">2021-10-11</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-02_node的安装和配置淘宝镜像源"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckumokpl60000y8v9ezdx6p0g.html">02_node的安装和配置淘宝镜像源</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="安装node的步骤："><a href="#安装node的步骤：" class="headerlink" title="安装node的步骤："></a>安装node的步骤：</h2><h3 id="1、下载node安装包"><a href="#1、下载node安装包" class="headerlink" title="1、下载node安装包"></a>1、下载node安装包</h3><p>Node.js安装包及源码下载地址：<a target="_blank" rel="noopener" href="http://nodejs.cn/download/%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%98%AFnode%E4%B8%AD%E6%96%87%E7%BD%91%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%9C%A8%E4%B8%AD%E6%96%87%E7%BD%91%E5%AE%89%E8%A3%85%E3%80%82">http://nodejs.cn/download/，这个是node中文网，建议在中文网安装。</a></p>
<p><a target="_blank" rel="noopener" href="https://nodejs.org/en/download/%E8%BF%99%E4%B8%AA%E6%98%AF%E5%9B%BD%E5%A4%96%E7%9A%84node%E7%BD%91%E7%AB%99%EF%BC%8C%E5%AE%B9%E6%98%93%E4%B8%8B%E8%BD%BD%E4%B8%8D%E4%B8%8B%E6%9D%A5%E3%80%82">https://nodejs.org/en/download/这个是国外的node网站，容易下载不下来。</a></p>
<p>根据不同平台系统选择需要的Node.js安装包。</p>
<h3 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h3><p>1)、下载完成后，双击下载后的安装包 node-v6.10.3-x64，进入node的安装向导界面，直接点击next。</p>
<p>2)、然后勾选接受协议选项，点击Next，开始下一步。</p>
<p>3)、选择nodejs的安装位置，Node.js默认安装目录。为：”C:\Program Files\nodejs\”，你可以修改目录，并点击next（下一步）。</p>
<p>4)、点击树形图标来选择你需要的安装模式，然后点击下一步。</p>
<p>5)、点击Install（安装）开始安装Node.js。</p>
<p>6)、等待一会，点击finish完成。</p>
<p><strong>以上操作，和普通软件安装步骤一样</strong></p>
<p>7)、打开cmd，输入命令，检查node是否安装成功，显示如下图所示版本号，即是安装成功。</p>
<img src="imgs/2021.10.11/图片1.png">

<p>8)、Node.js安装完成后npm也就安装上了，可查看npm的版本，如下图：</p>
<img src="imgs/2021.10.11/图片2.png">

<h2 id="配置淘宝镜像源："><a href="#配置淘宝镜像源：" class="headerlink" title="配置淘宝镜像源："></a>配置淘宝镜像源：</h2><p>9)、配置node的淘宝镜像源，在cmd中输入以下命令：</p>
<p>npm config set registry <a target="_blank" rel="noopener" href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
<p>10)、 验证是否配置成功：</p>
<p>在cmd中输入命令npm config get registry</p>
<p>如果返回的<a target="_blank" rel="noopener" href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> 说明镜像配置成功。</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-10-11T12:50:55.000Z" itemprop="datePublished">2021-10-11</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-01_js常量、变量、函数的声明"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckumokpli0001y8v9cgmb4ois.html">js常量、变量、函数的声明</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="js常量的两种声明方式"><a href="#js常量的两种声明方式" class="headerlink" title="js常量的两种声明方式"></a>js常量的两种声明方式</h2><h3 id="1-用const声明常量："><a href="#1-用const声明常量：" class="headerlink" title="1. 用const声明常量："></a>1. 用const声明常量：</h3><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<pre><code class="javascript">if (true) &#123;

 const MAX = 5;&#125;
 
MAX // Uncaught ReferenceError: MAX is not defined
</code></pre>
<p>上面代码表明改变常量的值会报错。</p>
<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p>
<pre><code class="javascript">if (true) &#123;
  const MAX = 5;
&#125;

MAX // Uncaught ReferenceError: MAX is not defined
</code></pre>
<p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<pre><code class="javascript">if (true) &#123;
  console.log(MAX); // ReferenceError
  const MAX = 5;
&#125;
</code></pre>
<p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p>
<p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p>
<pre><code class="javascript">var message = &quot;Hello!&quot;;
let age = 25;

// 以下两行都会报错
const message = &quot;Goodbye!&quot;;
const age = 30;
</code></pre>
<h3 id="2-用var声明常量："><a href="#2-用var声明常量：" class="headerlink" title="2.用var声明常量："></a>2.用var声明常量：</h3><p>没什么特殊的，全局常量。</p>
<h2 id="js变量的四种声明方式"><a href="#js变量的四种声明方式" class="headerlink" title="js变量的四种声明方式"></a>js变量的四种声明方式</h2><h3 id="1-用var声明变量："><a href="#1-用var声明变量：" class="headerlink" title="1.用var声明变量："></a>1.用var声明变量：</h3><p>var声明的变量是全局变量。</p>
<h3 id="2-用let声明变量："><a href="#2-用let声明变量：" class="headerlink" title="2.用let声明变量："></a>2.用let声明变量：</h3><p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p>
<pre><code class="javascript">for (let i = 0; i &lt; 10; i++) &#123;
  // ...
&#125;

console.log(i);
// ReferenceError: i is not defined
</code></pre>
<p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p>
<p>下面的代码如果使用<code>var</code>，最后输出的是<code>10</code>。</p>
<pre><code class="javascript">var a = [];
for (var i = 0; i &lt; 10; i++) &#123;
  a[i] = function () &#123;
    console.log(i);
  &#125;;
&#125;
a[6](); // 10
</code></pre>
<p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。</p>
<p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是 6。</p>
<pre><code class="javascript">var a = [];
for (let i = 0; i &lt; 10; i++) &#123;
  a[i] = function () &#123;
    console.log(i);
  &#125;;
&#125;
a[6](); // 6
</code></pre>
<p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p>
<h3 id="3-用const声明变量："><a href="#3-用const声明变量：" class="headerlink" title="3.用const声明变量："></a>3.用const声明变量：</h3><p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<pre><code class="javascript">const foo;
// SyntaxError: Missing initializer in const declaration
</code></pre>
<p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p>
<p>const声明常数和变量的本质：</p>
<p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<pre><code class="javascript">const foo = &#123;&#125;;

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only
</code></pre>
<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>下面是另一个例子。</p>
<pre><code class="javascript">const a = [];
a.push(&#39;Hello&#39;); // 可执行
a.length = 0;    // 可执行
a = [&#39;Dave&#39;];    // 报错
</code></pre>
<p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p>
<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>
<pre><code class="javascript">const foo = Object.freeze(&#123;&#125;);

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
</code></pre>
<p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<pre><code class="javascript">var constantize = (obj) =&gt; &#123;
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; &#123;
    if ( typeof obj[key] === &#39;object&#39; ) &#123;
      constantize( obj[key] );
    &#125;
  &#125;);
&#125;;
</code></pre>
<h3 id="4-用function声明变量："><a href="#4-用function声明变量：" class="headerlink" title="4.用function声明变量："></a>4.用function声明变量：</h3><p>在ES2015之前，声明变量只有var 和 function 这两个关键字，var 用于声明普通变量，function用于声明函数或者方法（高级变量，方法和函数的区别在下面），因此function声明变量和function声明函数是一个意思，所以这部分内容放在了function声明函数里。</p>
<p>同时var声明的变量和function声明的变量会有变量提升的问题。函数提升在前，变量提升在后。也就是function声明的变量在上面，var声明的变量在它的下面。</p>
<img src="imgs/2021.10.09/图片1.png">

<p>方法（method）和函数（function）的区别：<br>　　1）函数是一段代码，通过名字来进行调用。它能将一些数据（参数）传递进去进行处理，然后返回一些数据（返回值），也可以没有返回值。<br>　　所有传递给函数的数据都是显式传递的。函数和对象无关。<br>　　2）方法也是一段代码，也是通过名字来进行调用，但它跟一个对象相关联。方法和函数大致上是相同的，但有两个主要的不同之处：<br>　　方法中的数据是隐式传递的；方法和对象相关。<br>　　方法可以操作类内部的数据（请记住，对象是类的实例化–类定义了一个数据类型，而对象是该数据类型的一个实例化）</p>
<p>方法（method）是通过对象调用js函数。也就是说，方法也是函数，只是比较特殊的函数。</p>
<p>当将函数和对象和写在一起时，函数（function）就变成了方法（method）。有对象时的函数成为方法，无对象时的函数称为方法。</p>
<h2 id="js函数的两种声明方式"><a href="#js函数的两种声明方式" class="headerlink" title="js函数的两种声明方式"></a>js函数的两种声明方式</h2><h3 id="1-用var声明函数"><a href="#1-用var声明函数" class="headerlink" title="1.用var声明函数"></a>1.用var声明函数</h3><img src="imgs/2021.10.09/图片2.png">

<p>此操作是把函数赋值给刚声明的h。 函数只有在var语句声明之后才能被调用，这种写法导致只能在这个函数下面写的代码才能调用此函数。</p>
<h3 id="2-用function声明函数"><a href="#2-用function声明函数" class="headerlink" title="2.用function声明函数"></a>2.用function声明函数</h3><img src="imgs/2021.10.09/图片3.png">

<p>函数可以在function声明之前被调用，这种写法可以使在这个函数上面写的代码就可以调用此函数。</p>
<h3 id="3-用Function-构造器声明函数"><a href="#3-用Function-构造器声明函数" class="headerlink" title="3.用Function()构造器声明函数"></a>3.用Function()构造器声明函数</h3><p>不推荐这种用法, 容易出问题</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-10-09T11:58:30.000Z" itemprop="datePublished">2021-10-09</time>
</div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%B9%E4%B8%89%E8%80%85%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86/" rel="tag">对三者的声明方式进行区分</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  

  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/" rel="tag">js的基本数据类型和引用数据类型详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8Enode%E5%90%8E%E7%AB%AF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="tag">mongodb的安装、使用，与node后端连接，前端的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E4%B8%89%E8%80%85%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86/" rel="tag">对三者的声明方式进行区分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E3%80%81%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">对象的引用、浅拷贝、深拷贝在内存中的实现过程、三者的区别</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/ckz0tqj9l0000mcv968j96rzy.html">09_mongodb数据库使用流程</a>
          </li>
        
          <li>
            <a href="/ckwvnv7iz0000l8v934zt8fgu.html">08_js经典输出顺序问题</a>
          </li>
        
          <li>
            <a href="/ckwstx9ps0000mwv9ew0l4cy0.html">07_对象的引用、浅拷贝、深拷贝</a>
          </li>
        
          <li>
            <a href="/ckwstwhy100008ov97drxan3v.html">06_js基本类型和引用类型</a>
          </li>
        
          <li>
            <a href="/ckweotwk10000r0v99zsa8chl.html">05_封装一个随机颜色</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <div class="footer-wrap">
        <div class="footer-inner"> 
            小豆子的博客 &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1630473019367.js"></script>


<script src="/dist/custom.js?1630473019367.js"></script>









</body>

</html>