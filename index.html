<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>小豆子的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1630473019367.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="MissDou">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>小豆子的博客</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-21_vue的自定义指令"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkth9ho0000awv91ouzgrxo.html">21_vue的自定义指令</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="什么是vue的自定义指令？"><a href="#什么是vue的自定义指令？" class="headerlink" title="什么是vue的自定义指令？"></a>什么是vue的自定义指令？</h2><p>Vue里面有许多内置的指令，比如<code>v-if</code>和<code>v-show</code>，这些丰富的指令能满足我们的绝大部分业务需求，不过在需要一些特殊功能时，我们仍然希望对<code>DOM</code>进行底层的操作，这时就要用到自定义指令。</p>
<h2 id="使用方法？"><a href="#使用方法？" class="headerlink" title="使用方法？"></a>使用方法？</h2><pre><code>app.directive(&#39;focus&#39;, &#123;
    beforeMount: function (el) &#123; 
        // 每当指令绑定到元素上的时候，会立即执行这个beforeMount函数，只执行一次
        // 注意： 在每个函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数，是一个原生的JS对象
        // 在元素刚绑定了指令的时候还没有插入到DOM中去的时候调用focus方法没有作用。因为，一个元素只有插入DOM之后才能获取焦点
        // el.focus()
    &#125;,
    mounted: function (el) &#123;  
        // 指定绑定的远古三插入到DOM中的时候执行【触发1次】
        el.focus()
    &#125;,
    updated : function (el) &#123;  
        // 在包含组件的 VNode 及其子组件的 VNode 更新后调用
    &#125;
&#125;)
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:16:47.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-20_vue等单页面应用及其优缺点"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzktd6qh00030wv9e41w20ox.html">20_vue等单页面应用及其优缺点</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="什么是单页面应用？"><a href="#什么是单页面应用？" class="headerlink" title="什么是单页面应用？"></a>什么是单页面应用？</h2><p>单页Web应用（single page web application，SPA）：就是只有一个页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说模块化的开发和设计显得相当重要。</p>
<h2 id="单页Web应用的优点："><a href="#单页Web应用的优点：" class="headerlink" title="单页Web应用的优点："></a>单页Web应用的优点：</h2><p>1、提供了更加吸引人的用户体验：具有桌面应用的即时性、网站的可移植性和可访问性。<br>2、单页应用的内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷。<br>3、单页应用没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象<br>4、单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍。<br>5、良好的前后端分离。后端不再负责模板渲染、输出页面工作，后端API通用化，即同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端。</p>
<h2 id="单页Web应用的缺点："><a href="#单页Web应用的缺点：" class="headerlink" title="单页Web应用的缺点："></a>单页Web应用的缺点：</h2><p>1、首屏加载慢<br>2、SEO问题，不利于百度，360等搜索引擎收录。<br>3、容易造成CSS命名冲突。<br>4、前进、后退、地址栏、书签等，都需要程序进行管理，页面的复杂度很高，需要一定的技能水平和开发成本高。</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:13:45.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-19_vue-cli工作中如何自定义一个过滤器"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzktd6qe00010wv947ll8kzu.html">19_vue-cli工作中如何自定义一个过滤器</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>vue3移除了过滤器的用法，建议我们使用计算属性或者方法来替换，但是保留了全局过滤器的使用</p>
<pre><code>// main.js
const app = createApp(App)

//app.config.globalProperties 其实就是 Vue.prototype
app.config.globalProperties.$filters = &#123;
  currencyUSD(value) &#123;
    return &#39;$&#39; + value
  &#125;
&#125;

&lt;template&gt;
  &lt;h1&gt;Bank Account Balance&lt;/h1&gt;
  &lt;p&gt;&#123;&#123; $filters.currencyUSD(accountBalance) &#125;&#125;&lt;/p&gt;
&lt;/template&gt;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:10:57.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-18_vue生命周期和生命周期钩子函数"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzktd6qg00020wv9emgh00qy.html">18_vue生命周期和生命周期钩子函数</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="什么是vue生命周期？"><a href="#什么是vue生命周期？" class="headerlink" title="什么是vue生命周期？"></a>什么是vue生命周期？</h2><p><code>vue 的生命周期是：</code> vue 实例从创建到销毁，也就是从<code>开始创建</code>、<code>初始化数据</code>、<code>编译模板</code>、<code>挂载Dom→渲染</code>、<code>更新→渲染</code>、<code>卸载</code>等一系列过程。</p>
<h2 id="什么是vue生命周期钩子函数？"><a href="#什么是vue生命周期钩子函数？" class="headerlink" title="什么是vue生命周期钩子函数？"></a>什么是vue生命周期钩子函数？</h2><p>在vue声明周期过程中也会<code>运行</code>一些叫做<code>生命周期钩子的函数</code>，这给了<code>用户</code>在不同阶段<code>添加自己的代码</code>的机会。</p>
<h2 id="22-vue生命周期钩子函数有哪些"><a href="#22-vue生命周期钩子函数有哪些" class="headerlink" title="22.vue生命周期钩子函数有哪些?"></a>22.vue生命周期钩子函数有哪些?</h2><table>
<thead>
<tr>
<th>生命周期钩子函数（11个）</th>
<th>类型</th>
<th>详细</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>Function</td>
<td>在<code>实例初始化之后</code>，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</td>
</tr>
<tr>
<td>created</td>
<td>Function</td>
<td>在<code>实例创建完成后</code>被立即调用。在这一步，实例已完成以下的配置：<code>数据观测 (data observer)</code>， <code>属性和方法的运算</code>，<code>watch/event 事件回调</code>。然而，挂载阶段还没开始，$el 属性目前不可见。</td>
</tr>
<tr>
<td>beforeMount</td>
<td>Function</td>
<td>在<code>挂载开始之前</code>被调用：相关的 render 函数首次被调用。</td>
</tr>
<tr>
<td>mounted</td>
<td>Function</td>
<td><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并<code>挂载到实例上去之后</code>调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>Function</td>
<td><code>数据更新时调用</code>，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。<strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></td>
</tr>
<tr>
<td>updated</td>
<td>Function</td>
<td>由于数据更改导致的<code>虚拟 DOM 重新渲染和打补丁</code>，在这<code>之后</code>会<code>调用</code>该钩子。</td>
</tr>
<tr>
<td>activated</td>
<td>Function</td>
<td><code>keep-alive 组件激活时调用</code>。<strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td>deactivated</td>
<td>Function</td>
<td><code>keep-alive 组件停用时调用</code>。<strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td>beforeUnmounted</td>
<td>Function</td>
<td>实例销毁之前调用。在这一步，实例仍然完全可用。<strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td>unmounted</td>
<td>Function</td>
<td>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<strong>该钩子在服务器端渲染期间不被调用。</strong></td>
</tr>
<tr>
<td>errorCaptured（2.5.0+ 新增）</td>
<td>(err: Error, vm: Component, info: string) =&gt; ?boolean</td>
<td>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<pre><code>1、mounted、updated不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用vm.$nextTick替换掉mounted、updated：

updated: function () &#123;
    this.$nextTick(function () &#123;
        // Code that will run only after the
        // entire view has been re-rendered
    &#125;)
&#125;

2、http请求建议在 created 生命周期内发出
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:05:33.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-17_vue监听键盘事件的按键修饰符"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzktd6q400000wv90edjdd1i.html">17_vue监听键盘事件的按键修饰符</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>我们可以通过按键修饰符来监听键盘事件中的按键 。<code>Vue</code>允许为 <code>v-on</code>在监听键盘事件时添加<code>按键修饰符</code>：</p>
<pre><code>&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;

&lt;!-- 缩写语法 --&gt;
&lt;input @keyup.enter=&quot;submit&quot;&gt;
</code></pre>
<p><strong>全部的按键别名：</strong></p>
<pre><code>- .enter
- .tab
- .delete (捕获“删除”和“退格”键)
- .esc
- .space
- .up
- .down
- .left
- .right
</code></pre>
<p><strong>系统修饰键：</strong></p>
<blockquote>
<p>2.1.0 新增</p>
</blockquote>
<pre><code>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。
- .ctrl
- .alt
- .shift
- .meta

&lt;!-- Alt + C --&gt;
&lt;input @keyup.alt.67=&quot;clear&quot;&gt;

&lt;!-- Ctrl + Click --&gt;
&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;
</code></pre>
<blockquote>
<p>2.5.0 新增</p>
</blockquote>
<pre><code>.exact修饰符允许你控制由精确的系统修饰符组合触发的事件。

&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;
&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;
&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;
&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;
</code></pre>
<p><strong>鼠标按钮修饰符：</strong></p>
<blockquote>
<p>2.2.0 新增</p>
</blockquote>
<pre><code>- .left
- .right
- .middle

这些修饰符会限制处理函数仅响应特定的鼠标按钮。
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:01:26.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-16_vue常用的修饰符"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzktjh8p00007kv91brh8040.html">16_vue常用的修饰符</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="v-on指令常用修饰符"><a href="#v-on指令常用修饰符" class="headerlink" title="v-on指令常用修饰符"></a>v-on指令常用修饰符</h2><pre><code>- .stop - 调用 event.stopPropagation()，禁止事件冒泡。
- .prevent - 调用 event.preventDefault()，阻止事件默认行为。
- .capture - 添加事件侦听器时使用 capture 模式。
- .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
- .&#123;keyCode | keyAlias&#125; - 只当事件是从特定键触发时才触发回调。
- .native - 监听组件根元素的原生事件。
- .once - 只触发一次回调。
- .left - (2.2.0) 只当点击鼠标左键时触发。
- .right - (2.2.0) 只当点击鼠标右键时触发。
- .middle - (2.2.0) 只当点击鼠标中键时触发。




//注意： 如果是在自己封装的组件或者是使用一些第三方的UI库时，会发现一些事件并不起效果，这时就需要用.native修饰符了，如当我们使用element-ui中的el-input组件时的@keyup.enter事件：
&lt;el-input
  v-model=&quot;inputName&quot;
  placeholder=&quot;搜索你的文件&quot;
  @keyup.enter.native=&quot;searchFile(params)&quot;
  &gt;
&lt;/el-input&gt;
</code></pre>
<h2 id="v-bind指令常用修饰符"><a href="#v-bind指令常用修饰符" class="headerlink" title="v-bind指令常用修饰符"></a>v-bind指令常用修饰符</h2><pre><code>- .prop   被用于绑定 DOM 属性 (property)。(差别在哪里？)
- .camel  (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)
- .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。
</code></pre>
<h2 id="v-model-指令常用修饰符"><a href="#v-model-指令常用修饰符" class="headerlink" title="v-model 指令常用修饰符"></a>v-model 指令常用修饰符</h2><pre><code>- .lazy    取代 input 监听 change 事件
- .number  输入字符串转为数字
- .trim    输入首尾空格过滤
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T04:55:12.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/v-on-v-bind-v-model%E6%8C%87%E4%BB%A4%E5%B8%B8%E7%94%A8%E4%BF%AE%E9%A5%B0%E7%AC%A6/" rel="tag">v-on,v-bind,v-model指令常用修饰符</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-15_什么是vuex"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzksi8950000p0v9hlb9ajwq.html">15_什么是vuex</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="什么是vuex？"><a href="#什么是vuex？" class="headerlink" title="什么是vuex？"></a>什么是vuex？</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理器，采用 集中式存储 管理所有组件的状态。<br>主要用于维护vue组件间共用的一些 变量 和 方法</p>
<p><strong>vuex的原理其实非常简单，它为什么能实现所有的组件共享同一份数据？</strong></p>
<p>因为vuex生成了一个store实例，并且把这个实例挂在了所有的组件上，所有的组件引用的都是同一个store实例。<br>store实例上有数据，有方法，方法改变的都是store实例上的数据。由于其他组件引用的是同样的实例，所以一个组件改变了store上的数据，导致另一个组件上的数据也会改变，就像是一个对象的引用。</p>
<h2 id="vuex的核心概念？"><a href="#vuex的核心概念？" class="headerlink" title="vuex的核心概念？"></a>vuex的核心概念？</h2><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。</p>
<p><strong>vuex的核心概念和核心概念图：</strong><br>1、state - Vuex store实例的根状态对象，用于定义共享的状态变量。<br>2、Action -动作，向store发出调用通知，执行本地或者远端的某一个操作（可以理解为store的methods）<br>3、Mutations -修改器，它只用于修改state中定义的状态变量。<br>4、getter -读取器，外部程序通过它获取变量的具体值，或者在取值前做一些计算（可以认为是store的计算属性）</p>
<p><strong>Vuex的应用场景：</strong><br>Vuex主要用于：<br> 1、多层嵌套的组件之间进行状态传递<br> 2、兄弟组件间进行状态传递时（当然也可以使用中央事件总线BUS）<br> 3、多组件共享状态时</p>
<p>更为具体的场景：组件之间的状态、音乐播放、登录状态、加入购物车…</p>
<img src="imgs/2022.02.13.2/图片1.png">

<h2 id="vuex的使用？"><a href="#vuex的使用？" class="headerlink" title="vuex的使用？"></a>vuex的使用？</h2><pre><code>#1.安装vuex
npm install vuex@next --save

#2.main.js
import &#123; createStore &#125; from &quot;vuex&quot;;

// new Vuex.Store()实例，得到一个数据仓储对象
// 可以在组件中通过this.$store.state.xx 来访问store中的数据
var store = createStore(&#123;
    //state相当于组件中的data
    state: &#123;
        count: 0
    &#125;,
    //如果要修改store中state的值，需要调用 mutations提供的方法，可以通过this.$store.commit(&#39;方法名&#39;)来调用
    mutations: &#123;
        increment(state) &#123;
            state.count++
        &#125;,
        //mutations函数参数列表中最多支持两个参数，其中参数1是state； 参数2是通过commit提交过来的参数；
        subtract(state, obj) &#123;
            console.log(obj)
            state.count -= obj.step;
        &#125;
    &#125;,
    getters: &#123;
        //这里的getters只负责对外提供数据，不负责修改数据，如果想要修改 state 中的数据需要在mutations中修改
        optCount: function (state) &#123;
            return &#39;当前最新的count值是：&#39; + state.count
        &#125;
    &#125;
&#125;)

// 总结：
// 1. state中的数据，不能直接修改，如果想要修改，必须通过 mutations
// 2. 如果组件想要直接 从 state 上获取数据： 需要 this.$store.state.***
// 3. 如果组件想要修改数据，必须使用 mutations 提供的方法，需要通过 this.$store.commit(&#39;方法的名称&#39;， 唯一的一个参数)
// 4. store中state上的数据在对外提供的时候建议做一层包装，推荐使用 getters。调用的时候则用this.$store.getters.***

import &#123; createApp &#125; from &quot;vue&quot;;
import App from &quot;./App.vue&quot;;
import store from &#39;./store&#39;

const app = createApp(App);
//挂载路由实例(use方法挂载插件)
app.use(store).mount(&quot;#app&quot;);

#3.index.html
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
&lt;/body&gt;

#4.App.vue
&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;这是 App 组件&lt;/h1&gt;
        &lt;hr&gt;
        &lt;counter&gt;&lt;/counter&gt;
        &lt;hr&gt;
        &lt;amount&gt;&lt;/amount&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import counter from &quot;./components/counter.vue&quot;;
    import amount from &quot;./components/amount.vue&quot;;

    export default &#123;
        data() &#123;
            return &#123;&#125;;
        &#125;,
        components: &#123;
            counter,
            amount
        &#125;
    &#125;;
&lt;/script&gt;

#5.components/amount.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;&#123;&#123; $store.getters.optCount &#125;&#125;&lt;/h3&gt;
  &lt;/div&gt;
&lt;/template&gt;

#6.components/counter.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;input type=&quot;button&quot; value=&quot;绑定事件-减少&quot; @click=&quot;sub&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;绑定事件-增加&quot; @click=&quot;add&quot;&gt;
    &lt;br&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;$store.state.count&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  data() &#123;
    return &#123;
    &#125;;
  &#125;,
  methods: &#123;
    add() &#123;
       this.$store.commit(&quot;increment&quot;);
    &#125;,
    sub() &#123;
      this.$store.commit(&quot;subtract&quot;,&#123; step:3&#125;);
    &#125;
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T04:45:24.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-14_vue开发命令npm-run-dev输入后的执行过程"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzks8ap00000vov939wggxj7.html">14_vue开发命令npm run dev输入后的执行过程</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <ol>
<li>npm run dev 是执行配置在package.json中的脚本，比如：</li>
</ol>
<pre><code class="javascript">&quot;scripts&quot;: &#123;
    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config webpack.conf.js&quot;,
    &quot;start&quot;: &quot;npm run dev&quot;,
    &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;,
    &quot;build&quot;: &quot;node build/build.js&quot;
  &#125;,
  
npm run dev 执行的就是webpack-dev-server --inline ....命令,通过webpack-dev-server开启一个本地调试服务器。
</code></pre>
<ol start="2">
<li><p>在webpack.conf.js文件中找到App的入口文件  ./src/main.js</p>
<pre><code>entry: &#123;
   app: &#39;./src/main.js&#39;
&#125;,
</code></pre>
</li>
<li><p>main.js用到了页面元素#app、用到了路由和根组件App，并根据这些信息创建一个vue实例</p>
</li>
</ol>
<pre><code>new Vue(&#123;
     el: &#39;#app&#39;,
     router,
     components: &#123; App &#125;,
     template: &#39;&lt;App/&gt;&#39;
&#125;)
</code></pre>
<ol start="4">
<li>webpack-dev-server会将main.js中的代码以及所有引用打包成一个bundle.js，然后配置到内存中</li>
<li>webpack.config.js中配置的HtmlWebpackPlugin会将index.html文件配置到内存，并且将内存中的bundle.js注入到内存中的index.html中</li>
</ol>
<pre><code>new HtmlWebpackPlugin(&#123;
      filename: &#39;index.html&#39;,
      template: &#39;index.html&#39;,
      inject: true
&#125;),
</code></pre>
<ol start="6">
<li>根据webpack.config.js中所配置的devServer的信息，会决定是否自动打开浏览器呈现网页</li>
</ol>
<pre><code>devServer: &#123; 
    open: true, // 自动打开浏览器
    port: 3000, // 设置启动时候的运行端口
    contentBase: &#39;src&#39;, // 指定托管的根目录
    hot: true // 启用热更新 的 第1步
&#125;,
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T04:42:05.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-13_函数的去抖和节流"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzks19kt00001wv9405u4kt5.html">13_函数的去抖和节流</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="函数的去抖"><a href="#函数的去抖" class="headerlink" title="函数的去抖"></a>函数的去抖</h2><p>函数调用n秒后才会执行，如果函数在n秒内被调用的话则函数不执行，重新计算执行时间。函数去抖主要避免快速多次执行函数（操作DOM，加载资源等等）给内存带来大量的消耗从而一定程度上降低性能问题。</p>
<p>  函数去抖的应用场景：<br>    1.监控键盘keypress事件，每当内容变化的时候就向服务器发送请求<br>    2.在页面滚动的时候监控页面的滚动事件，会频繁执行scroll事件<br>    3.监控页面的resize事件，拉动窗口改变大小的时候，resize事件被频繁的执行</p>
<p>上面三种场景中都会频繁触发指定事件，比如第一种情况，每当输入框内容变化之后就向服务器发送请求，可能会导致一秒钟向服务器请求很多次，这显然是不合理的，我们可以使用函数去抖来优化。</p>
<pre><code>//loadsh里有去抖函数的封装

 &lt;input type=&quot;text&quot; oninput=&quot;textInput()&quot;&gt;
       
       //模拟发送请求的方法
        function ajax() &#123;
            console.log(&quot;发送请求&quot;)
        &#125;
        //文本框输入内容的时候频繁的触发func方法
        var func = debounce(ajax,1000)
        function textInput() &#123;
            func();
        &#125;
    
        //函数去抖方法的封装
        //debounce: 当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。
        function debounce(method, delay) &#123;
            var timer = null;
            return function () &#123;
                var context = this
                var args = arguments;
                clearTimeout(timer);
                timer = setTimeout(function () &#123;
                    method.apply(context, args);
                &#125;, delay);
            &#125;
        &#125;
</code></pre>
<h2 id="函数的节流"><a href="#函数的节流" class="headerlink" title="函数的节流"></a>函数的节流</h2><p>函数节流（throttle）：函数预先设定一个执行周期(或者节流阀)，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p>
<pre><code>function throttle(method,duration)&#123;
        var  begin = new Date();
        return function()&#123;
            var context = this
            var args=arguments
            var current=new Date();
            if(current-begin&gt;=duration)&#123;
                 method.apply(context,args);
                 begin = current;
            &#125;
        &#125;
&#125;
function resizehandler()&#123;
    console.log(++n);
&#125;
window.onresize=throttle(resizehandler,500);
</code></pre>
<p>函数节流的应用场景：<br>1.上拉下拉刷新，每拉动一次彻底完毕之后才可以下一次拉动<br>2.图片轮播动画，每一张图片动画完成之后才开始下一个图片的动画</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T04:33:24.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-12_跨域问题的解决方案"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkrt8zl0000ycv9adxhabkz.html">12_跨域问题的解决方案</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h2><p>同源策略可防止 JavaScript 发起跨域请求。源被定义为 URI、主机名和端口号的组合。此策略可防止页面上的恶意脚本通过该页面的文档对象模型，访问另一个网页上的敏感数据。</p>
<p>同源策略： 协议、主机、端口必须完全一致。</p>
<h2 id="跨域问题产生的原因？"><a href="#跨域问题产生的原因？" class="headerlink" title="跨域问题产生的原因？"></a>跨域问题产生的原因？</h2><p>浏览器的同源策略导致了跨域。在前端开发中，当我们使用ajax/fetch这些技术向服务器发送网络请求的时候，当协议、主机（域名）、端口号有任何一个不一致的时候，则构成跨域。</p>
<p>浏览器只有使用ajax发送请求才会出现跨域。href属性与src属性不会出现跨域。</p>
<h2 id="跨域问题的解决方案？"><a href="#跨域问题的解决方案？" class="headerlink" title="跨域问题的解决方案？"></a>跨域问题的解决方案？</h2><p>跨域问题有很多中解决方案：我所用过的有：</p>
<p>1.jsonp 他的本质是使用script标签去发送请求，然后服务器返回一段js脚本以供客户端执行</p>
<p>2.cors 他需要在服务器端配置跨域访问的响应头</p>
<pre><code> res.writeHead(200, &#123;
        &quot;Content-Type&quot;: &quot;text/html; charset=UTF-8&quot;,
        &quot;Access-Control-Allow-Origin&quot;:&#39;http://localhost&#39;,
        &#39;Access-Control-Allow-Methods&#39;: &#39;GET, POST, OPTIONS&#39;,
        &#39;Access-Control-Allow-Headers&#39;: &#39;X-Requested-With, Content-Type&#39;
    &#125;);
</code></pre>
<p>3.在前端的工程化项目(webpack)中,我们可以通过配置devserver的proxy来解决跨域访问的问题。他的原理是在本地开启一个服务器向数据服务器发送请求，因为服务器和服务器之间是没有跨域，配置在客户端。</p>
<p>4.但是因为webpack的devserver只在开发环境下有效，当项目发布上线之后仍然会有跨域问题，为了解决项目上线的跨域问题，我们配置服务器的反向代理（nginx），配置在服务器的。</p>
<p>5.除此之外，我还知道当项目打包成apk之后就不存在跨域问题了，所以如果项目要打包成apk，我们需要在项目中的所有请求中写全路径(此时我们可以配置axios.default.baseURL来解决)</p>
<p>6.iframe 嵌套通讯，postmessage</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T04:22:43.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  

  
    <nav class="pagination">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next</a>
    </nav>
  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/" rel="tag">js的基本数据类型和引用数据类型详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8Enode%E5%90%8E%E7%AB%AF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="tag">mongodb的安装、使用，与node后端连接，前端的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/v-on-v-bind-v-model%E6%8C%87%E4%BB%A4%E5%B8%B8%E7%94%A8%E4%BF%AE%E9%A5%B0%E7%AC%A6/" rel="tag">v-on,v-bind,v-model指令常用修饰符</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%80%E4%B9%88%E6%98%AFMVVM%EF%BC%8CMVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E4%BB%A5%E5%8F%8A%E4%B8%8EMVC%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">什么是MVVM，MVVM模式的优点以及与MVC模式的区别</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E4%B8%89%E8%80%85%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86/" rel="tag">对三者的声明方式进行区分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E3%80%81%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">对象的引用、浅拷贝、深拷贝在内存中的实现过程、三者的区别</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/ckzkth9ho0000awv91ouzgrxo.html">21_vue的自定义指令</a>
          </li>
        
          <li>
            <a href="/ckzktd6qh00030wv9e41w20ox.html">20_vue等单页面应用及其优缺点</a>
          </li>
        
          <li>
            <a href="/ckzktd6qe00010wv947ll8kzu.html">19_vue-cli工作中如何自定义一个过滤器</a>
          </li>
        
          <li>
            <a href="/ckzktd6qg00020wv9emgh00qy.html">18_vue生命周期和生命周期钩子函数</a>
          </li>
        
          <li>
            <a href="/ckzktd6q400000wv90edjdd1i.html">17_vue监听键盘事件的按键修饰符</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <div class="footer-wrap">
        <div class="footer-inner"> 
            小豆子的博客 &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1630473019367.js"></script>


<script src="/dist/custom.js?1630473019367.js"></script>









</body>

</html>