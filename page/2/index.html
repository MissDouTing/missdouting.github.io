<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>小豆子的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1630473019367.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="MissDou">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>小豆子的博客</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-46_js延迟加载的方式有哪些"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdn0008r0v9770t0w5s.html">46_js延迟加载的方式有哪些</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <ol>
<li><p>defer 和 async :    js文件的加载不会堵塞DOM的解析</p>
<pre><code>1. defer 属性
&lt;script  src=&quot;file.js&quot; defer&gt;&lt;/script&gt; 
defer属性声明这个脚本中将不会有 document.write 或 dom 修改。
浏览器将会并行下载 file.js 和其它有 defer 属性的script，而不会阻塞页面后续处理。
 
defer属性在IE 4.0中就实现了，超过13年了！Firefox 从 3.5 开始支持defer属性 。
注：所有的defer 脚本保证是按顺序依次执行的。

2. async 属性
&lt;script src=&quot;file1.js&quot; async&gt;&lt;/script&gt; 
async属性是HTML5新增的。作用和defer类似，但是它将在下载后尽快执行，不能保证脚本会按顺序执行。它们将在onload 事件之前完成。
Firefox 3.6、Opera 10.5、IE 9 和 最新的Chrome 和 Safari 都支持 async 属性。可以同时使用 async 和 defer，这样IE 4之后的所有 IE 都支持异步加载。
</code></pre>
</li>
<li><p>动态创建 DOM 方式（创建 script，插入到 DOM 中，加载完毕后 callBack）</p>
<pre><code>var ga = document.createElement(&#39;script&#39;);
ga.type = &#39;text/javascript&#39;;
ga.async = true;
ga.src = &#39;xxxx&#39;;
var s = document.getElementsByTagName(&#39;script&#39;)[0];
s.parentNode.insertBefore(ga, s);
</code></pre>
</li>
<li><p>由于JavaScript的动态性，还有很多异步加载方法： XHR Injection、 XHR Eval、 Script In Iframe</p>
</li>
</ol>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:17:52.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-45_iframe的优缺点"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdl0006r0v9bquc82nb.html">45_iframe的优缺点</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>iframe的优点：
1.iframe能够原封不动的把嵌入的网页展现出来，iframe和主页面是并行加载的
2.如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。
3.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。
4.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。

iframe的缺点：
1.会产生很多页面，不容易管理。
2.iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。
3.代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。
4.很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。
5.iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。 分析了这么多，现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。
6.iframe会堵塞主页面的onload事件
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:15:54.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-44_创建函数的几种方式"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdl0007r0v92tyedjar.html">44_创建函数的几种方式</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>第一种（函数声明）：
function sum1(num1,num2)&#123;
    return num1+num2;
&#125;

第二种（函数表达式）：
var sum2 = function(num1,num2)&#123;
    return num1+num2;
&#125;

第三种(匿名函数)：
function()&#123;&#125;:只能自己执行自己

第四种(new Function创建函数)
let str = &#39;return &#39; + &#39;`Hello $&#123;name&#125;!`&#39;;
let func = new Function(&#39;name&#39;, str);
func(&#39;Jack&#39;) // &quot;Hello Jack!&quot;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:14:23.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-43_javascript继承的方法"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdk0005r0v9anio32tj.html">43_javascript继承的方法</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>1.借助构造函数实现继承</p>
<pre><code>   //  定义父类
    function Parent1 () &#123;
        this.name = &#39;xxx&#39;,
        this.age = 18
    &#125;
    //  定义子类
    function Child1 () &#123;
        //通过call()方法改变Child1的this指向使子类的函数体内执行父级的构造函数从而实现继承效果
        Parent1.call(this)
        this.address = &#39;yyy&#39;
    &#125;
    //  构建子类的实例s1
    var s1 = new Child1()
    console.log(s1.name)  //xxx
    缺点:该方法的实力(s1)无法使用父类(Parent1)的原型(prototype)中的属性和方法
    
</code></pre>
<p>2.借助原型链实现继承</p>
<pre><code> function Parent2 () &#123;
        this.name = &#39;xx&#39;,
        this.age = 19,
        this.play = [1,2,3]
    &#125;
    //  一样在父类添加say方法
    Parent2.prototype = &#123;
        say () &#123;
            console.log(&#39;say&#39;)
        &#125;
    &#125;
    function Child2 (address) &#123;
        this.address = &#39;yyy&#39;
    &#125;
    // 让子类的原型直接指向父类实例
    Child2.prototype = new Parent2()
    //  生成两个子类的实例s2、s3
    var s2 = new Child2()
    var s3 = new Child2()
    // s2实例继承了父类中的name属性
    console.log(s2.name)  //xx
    //  s2实例也同样继承了父类原型上的say方法
    console.log(s2.say())  //say
    缺点:在子类调用构造函数创建对象的时候，无法入参所有的属性值
</code></pre>
<p>3.组合继承</p>
<pre><code>   function Parent5 () &#123;
        this.name = &#39;xx&#39;,
        this.age = 20,
        this.play = [4,5,6]
    &#125;
    function Child5 (name,age,address) &#123;
        Parent5.call(this,name,age)
        this.address = address
    &#125;
    // 比较关键的一步
    Child5.prototype = new Parent5()
    var c = new Child5(&quot;zhangsan&quot;,19,&quot;无锡&quot;)
</code></pre>
<p>4.实例继承(为父类实例添加新特性，作为子类实例返回)</p>
<pre><code>  function Animal (name) &#123;
      // 属性
      this.name = name || &#39;Animal&#39;;
      // 实例方法
      this.sleep = function()&#123;
        console.log(this.name + &#39;正在睡觉！&#39;);
      &#125;
    &#125;
    // 原型方法
    Animal.prototype.eat = function(food) &#123;
      console.log(this.name + &#39;正在吃：&#39; + food);
    &#125;;

function Cat()&#123;
  var instance = new Animal();
  instance.name = name || &#39;Tom&#39;;
  return instance;
&#125;
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // false
</code></pre>
<p>5.拷贝继承</p>
<pre><code>   // 定义一个动物类
    function Animal (name) &#123;
      // 属性
      this.name = name || &#39;Animal&#39;;
      // 实例方法
      this.sleep = function()&#123;
        console.log(this.name + &#39;正在睡觉！&#39;);
      &#125;
    &#125;
    // 原型方法
    Animal.prototype.eat = function(food) &#123;
      console.log(this.name + &#39;正在吃：&#39; + food);
    &#125;;
    function Cat(name)&#123;
      var animal = new Animal();
     // 遍历拷贝属性
      for(var p in animal)&#123;
        Cat.prototype[p] = animal[p];
      &#125;
      Cat.prototype.name = name || &#39;Tom&#39;;
    &#125;

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:11:07.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-42_移动端兼容"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdj0004r0v9g4fgdgm6.html">42_移动端兼容</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>bootstrap中起步中有：</p>
<p>1&gt;ios移动端click事件300ms的延迟响应. 用fastclick来解决</p>
<p>2&gt;zepto的touch模块的tap事件有点透的问题，也是用fastclick来解决</p>
<p>3&gt;一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发，css增加cursor:pointer就搞定了</p>
<p>4&gt;ios下取消input在输入的时候英文首字母的默认大写</p>
<pre><code>&lt;input autocapitalize=&quot;off&quot;autocorrect=&quot;off&quot; /&gt;
</code></pre>
<p>5&gt;fixed定位缺陷</p>
<pre><code>ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位
android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位
ios4下不支持position:fixed

解决方案： 可用iScroll插件解决这个问题
</code></pre>
<p>6&gt;Input 的placeholder会出现文本位置偏上的情况</p>
<pre><code>input 的placeholder会出现文本位置偏上的情况：PC端设置line-height等于height能够对齐，而移动端仍然是偏上，解决是设置line-height：normal
</code></pre>
<p>7&gt;calc的兼容性处理</p>
<pre><code> CSS3中的calc变量在iOS6浏览器中必须加-webkit-前缀，目前的FF浏览器已经无需-moz-前缀。
 Android浏览器目前仍然不支持calc，所以要在之前增加一个保守尺寸：

div &#123;
    width: 95%;
    width: -webkit-calc(100% - 50px);
    width: calc(100% - 50px);
&#125;
</code></pre>
<p>8&gt;在移动端修改难看的点击的高亮效果，iOS和安卓下都有效：</p>
<pre><code>\ &#123;-webkit-tap-highlight-color:rgba(0,0,0,0);&#125;
</code></pre>
<p>9&gt;阻止旋转屏幕时自动调整字体大小</p>
<pre><code>html, body, form, fieldset, p, div, h1, h2, h3, h4, h5,h6 &#123;-webkit-text-size-adjust:none;&#125;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:09:49.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-41_闭包"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdi0003r0v91b7t9hh7.html">41_闭包</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>闭包就是函数嵌套函数，并将该内部函数作为返回值返回或者存储在某个对象的属性里，这时就会形成一个闭包。</p>
<pre><code class="javascript">function aa()&#123;
    var num = 10;
    return function bb()&#123;
        console.log(num);
    &#125;
&#125;

var b = aa();
</code></pre>
<pre><code>用途：
1.缓存，延长变量的作用域链
2.面向对象中的对象
3.实现封装，防止变量跑到外层作用域中，发生命名冲突

危害：
1.闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当的话会内存泄漏。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
2.性能问题，使用闭包时，会涉及到跨作用域访问，由于闭包内部变量优先级高于外部变量，所以多查找作用域链中的一个层次，就会在一定程度上影响查找速度。
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:07:03.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-40_正则表达式"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdf0001r0v958ka069x.html">40_正则表达式</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>\d   数字
\w   字母(数字 字母 下划线)
\s   空白字符
\D   非数字
\W   非字母
\S   非空白
.    通配符(匹配除了\n之外的所有字符)
\b   单词边界匹配

n*    匹配0个或多个n
n+    匹配至少1个n
n?    匹配0个或者1个n

n&#123;1,&#125;    n至少出现1次
n&#123;1,3&#125;   n出现1到3次
n&#123;1&#125;     n恰好出现1次

[abc]    取值在abc之间
[^abc]   取值在非abc
[a | b]  取值在a或者b之间
[a-z]    取值在a到z之间

i   忽略大小写匹配
g   全局匹配

^   表示开头
$   表示结束
</code></pre>
<p>例子：请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20</p>
<pre><code>答案： /^[A-Za-z_]\w&#123;4,19&#125;$/
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:03:55.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-39_DOM和HTML-DOM的区别和联系"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdh0002r0v9cvij0jwn.html">39_DOM和HTML DOM的区别和联系</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>DOM分为三部分：</p>
<p>（1）核心DOM：遍历DOM树、添加新节点、删除节点、修改节点</p>
<p>（2）HTML DOM：以一种简便的方法访问DOM树</p>
<p>（3）XML DOM：准用于操作XML文档</p>
<pre><code>核心DOM与HTML DOM的区别：
A.核心DOM(dom对象) ： Document,Node,  ElementNode,TextNode,AttributeNode，CommentNode,NodeList

核心DOM提供了统一的操作接口，如：createElement、appendChild、setAttribute等
核心DOM创建新元素：var newNode=document.createElement(&quot;img&quot;)
给元素添加属性：e.setAttribure()、e.setAttribureNode()
适用场合：核心DOM适合操作节点，如创建，删除，查找等

B.HTML DOM(js对象)：image,Table,Form,Input,Select等等HTML标签对象化
使用HTML DOM创建新元素：  var newNode = new Image()；
使用给元素添加属性：
img.src=&#39;&#39;;
img.id=&#39;&#39;;
imd.title=&#39;&#39;;
img.className=&#39;&#39;
img.style.display=&#39;&#39;;

适用场合：
HTML DOM适合操作属性，如读取或修改属性的值
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:02:34.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-38_bind、call、apply的区别"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzda0000r0v9b173h0qb.html">38_bind、call、apply的区别</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>bind、call、apply可以改变被调用函数中的this指向。</p>
<p>call和apply其实是一样的，区别就在call需要一个个传参，而apply可以入参一个数组。</p>
<p>call和apply都是在调用时触发指定的方法，同时改变指定方法中的this指向。而bind是返回一个已经修改this指向后的新函数，如果要触发该方法，我们需要手动调用。</p>
<pre><code>const newFunc = sayHi.bind(obj)
newFunc() // Hi! Tom
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:00:28.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-37_new一个对象内部过程"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkuw9720000fov9cqsm66ik.html">37_new一个对象内部过程</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>function Test()&#123;&#125;
const test = new Test()
</code></pre>
<ol>
<li>创建一个新对象：</li>
</ol>
<pre><code>const obj = &#123;&#125;
</code></pre>
<ol start="2">
<li>设置新对象的constructor属性为构造函数的名称，设置新对象的<code>__proto__</code>属性指向构造函数的prototype对象</li>
</ol>
<pre><code>obj.constructor = Test
obj.__proto__ = Test.prototype
</code></pre>
<ol start="3">
<li>使用新对象调用函数，函数中的this被指向新实例对象</li>
</ol>
<pre><code>Test.call(obj)
</code></pre>
<ol start="4">
<li>将初始化完毕的新对象地址，保存到等号左边的变量中</li>
</ol>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:56:52.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  

  
    <nav class="pagination">
        <a class="extend prev" rel="prev" href="/">Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next</a>
    </nav>
  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/" rel="tag">js的基本数据类型和引用数据类型详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8Enode%E5%90%8E%E7%AB%AF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="tag">mongodb的安装、使用，与node后端连接，前端的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%80%E4%B9%88%E6%98%AFMVVM%EF%BC%8CMVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E4%BB%A5%E5%8F%8A%E4%B8%8EMVC%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">什么是MVVM，MVVM模式的优点以及与MVC模式的区别</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E4%B8%89%E8%80%85%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86/" rel="tag">对三者的声明方式进行区分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E3%80%81%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">对象的引用、浅拷贝、深拷贝在内存中的实现过程、三者的区别</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/ckzkwo7zn0004pov9hsj5enki.html">56_Math、Array、String的方法和属性</a>
          </li>
        
          <li>
            <a href="/ckzkwo7zn0003pov97fd1c6ge.html">55_jquery的选择器</a>
          </li>
        
          <li>
            <a href="/ckzkwo7zm0002pov99rondnf2.html">54_本地存储和离线缓存的区别</a>
          </li>
        
          <li>
            <a href="/ckzkwo7zg0000pov97cvofrsp.html">53_浏览器的进程</a>
          </li>
        
          <li>
            <a href="/ckzkwo7zk0001pov9ed69ba5a.html">52_this指向问题</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <div class="footer-wrap">
        <div class="footer-inner"> 
            小豆子的博客 &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1630473019367.js"></script>


<script src="/dist/custom.js?1630473019367.js"></script>









</body>

</html>