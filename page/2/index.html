<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>小豆子的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1630473019367.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="MissDou">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>小豆子的博客</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-41_闭包"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdi0003r0v91b7t9hh7.html">41_闭包</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>闭包就是函数嵌套函数，并将该内部函数作为返回值返回或者存储在某个对象的属性里，这时就会形成一个闭包。</p>
<pre><code class="javascript">function aa()&#123;
    var num = 10;
    return function bb()&#123;
        console.log(num);
    &#125;
&#125;

var b = aa();
</code></pre>
<pre><code>用途：
1.缓存，延长变量的作用域链
2.面向对象中的对象
3.实现封装，防止变量跑到外层作用域中，发生命名冲突

危害：
1.闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当的话会内存泄漏。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
2.性能问题，使用闭包时，会涉及到跨作用域访问，由于闭包内部变量优先级高于外部变量，所以多查找作用域链中的一个层次，就会在一定程度上影响查找速度。
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:07:03.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-40_正则表达式"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdf0001r0v958ka069x.html">40_正则表达式</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>\d   数字
\w   字母(数字 字母 下划线)
\s   空白字符
\D   非数字
\W   非字母
\S   非空白
.    通配符(匹配除了\n之外的所有字符)
\b   单词边界匹配

n*    匹配0个或多个n
n+    匹配至少1个n
n?    匹配0个或者1个n

n&#123;1,&#125;    n至少出现1次
n&#123;1,3&#125;   n出现1到3次
n&#123;1&#125;     n恰好出现1次

[abc]    取值在abc之间
[^abc]   取值在非abc
[a | b]  取值在a或者b之间
[a-z]    取值在a到z之间

i   忽略大小写匹配
g   全局匹配

^   表示开头
$   表示结束
</code></pre>
<p>例子：请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20</p>
<pre><code>答案： /^[A-Za-z_]\w&#123;4,19&#125;$/
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:03:55.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-39_DOM和HTML-DOM的区别和联系"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzdh0002r0v9cvij0jwn.html">39_DOM和HTML DOM的区别和联系</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>DOM分为三部分：</p>
<p>（1）核心DOM：遍历DOM树、添加新节点、删除节点、修改节点</p>
<p>（2）HTML DOM：以一种简便的方法访问DOM树</p>
<p>（3）XML DOM：准用于操作XML文档</p>
<pre><code>核心DOM与HTML DOM的区别：
A.核心DOM(dom对象) ： Document,Node,  ElementNode,TextNode,AttributeNode，CommentNode,NodeList

核心DOM提供了统一的操作接口，如：createElement、appendChild、setAttribute等
核心DOM创建新元素：var newNode=document.createElement(&quot;img&quot;)
给元素添加属性：e.setAttribure()、e.setAttribureNode()
适用场合：核心DOM适合操作节点，如创建，删除，查找等

B.HTML DOM(js对象)：image,Table,Form,Input,Select等等HTML标签对象化
使用HTML DOM创建新元素：  var newNode = new Image()；
使用给元素添加属性：
img.src=&#39;&#39;;
img.id=&#39;&#39;;
imd.title=&#39;&#39;;
img.className=&#39;&#39;
img.style.display=&#39;&#39;;

适用场合：
HTML DOM适合操作属性，如读取或修改属性的值
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:02:34.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-38_bind、call、apply的区别"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkvyzda0000r0v9b173h0qb.html">38_bind、call、apply的区别</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>bind、call、apply可以改变被调用函数中的this指向。</p>
<p>call和apply其实是一样的，区别就在call需要一个个传参，而apply可以入参一个数组。</p>
<p>call和apply都是在调用时触发指定的方法，同时改变指定方法中的this指向。而bind是返回一个已经修改this指向后的新函数，如果要触发该方法，我们需要手动调用。</p>
<pre><code>const newFunc = sayHi.bind(obj)
newFunc() // Hi! Tom
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T06:00:28.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-37_new一个对象内部过程"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkuw9720000fov9cqsm66ik.html">37_new一个对象内部过程</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>function Test()&#123;&#125;
const test = new Test()
</code></pre>
<ol>
<li>创建一个新对象：</li>
</ol>
<pre><code>const obj = &#123;&#125;
</code></pre>
<ol start="2">
<li>设置新对象的constructor属性为构造函数的名称，设置新对象的<code>__proto__</code>属性指向构造函数的prototype对象</li>
</ol>
<pre><code>obj.constructor = Test
obj.__proto__ = Test.prototype
</code></pre>
<ol start="3">
<li>使用新对象调用函数，函数中的this被指向新实例对象</li>
</ol>
<pre><code>Test.call(obj)
</code></pre>
<ol start="4">
<li>将初始化完毕的新对象地址，保存到等号左边的变量中</li>
</ol>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:56:52.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-36_prototype和__proto__的关系"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkuw9770001fov96aba3xt7.html">36_prototype和__proto__的关系</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>1.函数有一个prototype属性，这个属性表示函数的原型
  这个属性中有三部分信息：构造函数   所有实例公共的属性和方法   __proto__
2.对象有一个__proto__属性，他指向函数的原型
  function Person(name,age)&#123;
      this.name = name;
      this.age = age;
  &#125;
  var p = new Person(&quot;zhangsan&quot;,18);
  p.__proto__ == Person.prototype;
3.函数原型中的信息
  Person.prototype.constructor == Person;
  Person.prototype.__proto__ == Object.prototype;
  Object.prototype.__proto__ == null
  
  
//区别
//a._proto_是隐式原型，prototype是显示原型
//b.prototype：每一个函数创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象
//c._proto_ ：javascript中任意的对象都有一个内置属性，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过_proto_来访问。
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:54:22.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-35_vue3的hook与react的hook不同点"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundlj0009psv92wak8gvv.html">35_vue3的hook与react的hook不同点</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>vue3的hook是借鉴了react的hook思想，vue3中自定义hook的写法与react看起来很类似，但实际使用是有些许不同，而内部实现原理更是完全不一样。</p>
<p>首先说下react hook的两个限制：</p>
<blockquote>
<ol>
<li><code>只在最顶层使用 Hook</code>，<code>不要在循环，条件或嵌套函数中调用 Hook</code></li>
<li><code>只在 React 函数中调用 Hook</code>，<code>不要在普通的 JavaScript 函数中调用 Hook</code></li>
</ol>
</blockquote>
<p>这在react官网也有专门介绍。</p>
<p>只能在最顶层使用Hook，这是因为react的hook是依靠调用的顺序来确认state对应的hook，每次重新渲染都会再调用hook，所以需要确保hook的调用顺序是不会变的。</p>
<p>再说下vue与react使用的不同之处：</p>
<blockquote>
<ol>
<li>setup只执行一遍，而react每次渲染都会重新执行hook</li>
<li>Hook需要更新值时Vue可以直接赋值，而react则需要调用hook的赋值函数</li>
<li>vue调用顺序无要求，也可以放在条件语句里，而react有要求</li>
</ol>
</blockquote>
<p>实现原理的不同：</p>
<p>vue中的hook是<code>响应式对象</code>，在render的时候读取到就会被<code>依赖收集</code>。</p>
<p>react中的hook本质是一个函数，每次重新渲染都需要再次调用，在声明的时候按照调用顺序通过{ value1, setValue1} -&gt; { value2, setValue2 }的<code>链表</code>结构存储，所以需要严格限制 Hook 的执行顺序和禁止条件调用。</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:49:41.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-34_vue的双向绑定的原理"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundln000dpsv96d0aez56.html">34_vue的双向绑定的原理</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>//1.由页面-&gt;数据的变化：通过给页面元素添加对应的事件监听来实现的
&lt;input v-model=&quot;value&quot; oninput=&quot;()=&gt;this.handleInput($event)&quot;&gt;
function handleInput(e)&#123;
    this.value = e.target.value
&#125;

//2.1.在vue2 options api中 由数据-&gt;页面的变化：通过数据劫持（Object.defineProperty） + 发布订阅模式来实现
具体流程：
A.Compile解析器会将页面上的插值表达式/指定翻译成对应Watcher以添加到订阅器维护的列表中
B.通过Object.defineProperty劫持数据的变化，一旦数据源发生变化会触发对应的set方法
C.在set方法中，通知订阅器(Dep)对象中维护的所有订阅者(Watcher)列表更新
D.每一个Watch会去更新对应的页面

//2.2在 vue3 composition api中，数据-&gt;页面变化是通过响应式系统来实现的，其内部是通过proxy来实现响应式，在proxy的get函数中收集依赖，并存储响应式数据与更新函数cb的映射关系；在proxy的set中，触发响应式数据对应的更新函数cb
// 在vue3composition api中数据-&gt;页面的变化  具体参照85题

//3.关于发布订阅模式    //发布订阅模式是什么
发布订阅模式又叫观察者模式，他定义了一种一对多的关系，让多个观察者对象同时监听某一个主体对象的变化，当这个主题对象的状态发生变化的时候就会通知所有的观察者对象，使得的他们能够自动更新自己。
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:46:51.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-33_vue-cli打包后会生成哪些文件"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundlk000apsv9940c90jb.html">33_vue-cli打包后会生成哪些文件</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <pre><code>dist
  --index.html       单页面文件
  --app.[hash].css   将组件中的css编译合并成一个app.[hash].css的文件
  --app.[hash].js    包含了所有components中的js代码
  /ˈvendə(r)/ 

  

  --vendor.[hash].js   包含了生产环境所有引用的node_modules中的代码
  --mainfest.[hash].js 包含了webpack运行环境及模块化所需的js代码
  --0.[hash].js        是vue-router使用了按需加载生产的js文件

这样拆分的好处是：每块组件修改重新编译后不影响其他未修改的js文件的hash值，这样能够最大限度地使用缓存，减少HTTP的请求数。
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:44:21.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-32_vue利用keep-alive标签实现组件缓存功能"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundlm000cpsv9cyb7hf2r.html">32_vue利用keep-alive标签实现组件缓存功能</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>实现某个组件的缓存功能，可用 keep-alive 标签与 vue-router的meta形式数据传递配合完成。</p>
<pre><code class="html">&lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt;
    &lt;keep-alive :include=&quot;cacheComponents&quot;&gt;
        &lt;component :is=&quot;Component&quot; /&gt;
    &lt;/keep-alive&gt;
&lt;/router-view&gt;
</code></pre>
<pre><code class="javascript">//第一步：在 app.vue 里面 template部分 使用 &lt;keep-alive&gt;&lt;/keep-alive&gt; 组件,然后使用cacheComponents来表示要缓存的组件

&lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt;
    &lt;keep-alive :include=&quot;cacheComponents&quot;&gt;
        &lt;component :is=&quot;Component&quot; /&gt;
    &lt;/keep-alive&gt;
&lt;/router-view&gt;

&lt;script&gt;
export default &#123;
  data() &#123;
    return &#123;
      cacheComponents: []
    &#125;;
  &#125;,
  created() &#123;
    //this.$router 获取路由对象   返回路由配置中需要缓存的组件数组信息
    console.log(this.$router)
    this.$router.options.routes.forEach(item =&gt; &#123;
      if (item.meta &amp;&amp; item.meta.cache) &#123;
        this.cacheComponents.push(item.name);
      &#125;
    &#125;);
  &#125;
&#125;;
&lt;/script&gt;

//第二步：在src/router.js中使用meta元数据指定要缓存的组件
import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;
import Login from &quot;../views/Login.vue&quot;;
import Register from &quot;../views/Register.vue&quot;;

const routes = [
  &#123;
    path: &quot;/login&quot;,
    name: &quot;login&quot;,
    component: Login,
    meta: &#123;
      cache: false,
    &#125;,
  &#125;,
  &#123;
    path: &quot;/register&quot;,
    name: &quot;register&quot;,
    component: Register,
    meta: &#123;
      cache: true,
    &#125;,
  &#125;,
  &#123; path: &quot;/&quot;, redirect: &quot;/register&quot; &#125;,
];

const router = createRouter(&#123;
  history: createWebHistory(),
  routes,
  linkActiveClass: &quot;router-active&quot;,
&#125;);

export default router;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:42:26.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  

  
    <nav class="pagination">
        <a class="extend prev" rel="prev" href="/">Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next</a>
    </nav>
  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/" rel="tag">js的基本数据类型和引用数据类型详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8Enode%E5%90%8E%E7%AB%AF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="tag">mongodb的安装、使用，与node后端连接，前端的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%80%E4%B9%88%E6%98%AFMVVM%EF%BC%8CMVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E4%BB%A5%E5%8F%8A%E4%B8%8EMVC%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">什么是MVVM，MVVM模式的优点以及与MVC模式的区别</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E4%B8%89%E8%80%85%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86/" rel="tag">对三者的声明方式进行区分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E3%80%81%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">对象的引用、浅拷贝、深拷贝在内存中的实现过程、三者的区别</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/ckzkw1mmm000098v96qneg6ml.html">51_es6常用语法</a>
          </li>
        
          <li>
            <a href="/ckzkvyzdq000cr0v92yrj72oj.html">50_js模块化规范</a>
          </li>
        
          <li>
            <a href="/ckzkvyzdp000ar0v98t6yeis5.html">49_JavaScript的严格模式</a>
          </li>
        
          <li>
            <a href="/ckzkvyzdo0009r0v9dtsgcq9p.html">48_减低页面加载时间的几种方法</a>
          </li>
        
          <li>
            <a href="/ckzkvyzdq000br0v9a5cjenzy.html">47_前端兼容问题的解决方案</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <div class="footer-wrap">
        <div class="footer-inner"> 
            小豆子的博客 &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1630473019367.js"></script>


<script src="/dist/custom.js?1630473019367.js"></script>









</body>

</html>