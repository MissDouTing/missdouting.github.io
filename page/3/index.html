<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>小豆子的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1630473019367.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="MissDou">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>小豆子的博客</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-31_vue-cli工程中如何使用背景图"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundll000bpsv9aqur46ce.html">31_vue-cli工程中如何使用背景图</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <blockquote>
<p>第一种方法：通过 <code>import</code> 引入</p>
</blockquote>
<pre><code>首先，引入要使用的背景图片：
&lt;script type=&quot;text/javascript&quot;&gt;
    import  cover  from  &quot;../assets/images/cover.png&quot;;
    export  default&#123;
        ...
    &#125;
&lt;/script&gt;

然后，通过 v-bind:style 使用：
&lt;div :style=&quot;&#123; backgroundImage:&#39;url(&#39; + cover + &#39;)&#39; &#125;&quot;&gt;&lt;/div&gt;
</code></pre>
<blockquote>
<p>第二种方法：通过 <code>require</code> 引入：</p>
</blockquote>
<pre><code>直接通过 v-bind 和 require 配合使用

&lt;div :style=&quot;&#123; backgroundImage:&#39;url(&#39; + require(&#39;../assets/images/couver.png&#39;) + &#39;)&#39; &#125;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>如果在css文件中使用图片作为背景，可以直接 background:url(../../logg.png)</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:40:33.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-30_如何适配移动端"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundli0008psv99pe7h39y.html">30_如何适配移动端</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p><strong>在css样式兼容性方面，我们可以使用autoprefixer插件</strong></p>
<pre><code>postcss可以被理解为一个平台，可以让一些插件在上面跑。它提供了一个解析器，可以将CSS解析成抽象语法树。通过PostCSS这个平台，我们能够开发一些插件，来处理CSS。热门插件如autoprefixer。

vue-cli已经自动集成了postcss，所以我们可以在postcss.config.js这个配置文件中直接添加autoprefixer这个插件
</code></pre>
<p><strong>在屏幕大小适配方面，我们可以使用下面两种方案</strong></p>
<p>a) 使用flexible和 postcss-px2rem，    //autoprefixer 自动补全css前缀的东西</p>
<pre><code>之前使用rem适配的思路：使用媒体查询，确定不同屏幕下html标签的font-size  (即1rem单位)，然后在写css样式的时候，就可以使用1rem , 2rem这样的单位来做适配了。

但是这种适配的问题是需要手动把px单位换算成rem单位，比较麻烦。对应的，我们可以使用flexible和 postcss-px2rem来解决这个问题
</code></pre>
<pre><code class="javascript">//1.安装flexible。 flexible主要是实现在各种不同的移动端界面实现一稿搞定所有的设备兼容自适应问题
npm install lib-flexible --save

//2.main.js引入flexible
import &#39;lib-flexible&#39;

//此时运行程序会看到html中自动加上了font-size    font-size的默认值为viewport的十分之一
//在页面中引入flexible.js后，flexible会在&lt;html&gt;标签上增加一个data-dpr属性和font-size样式（如下图）。

//3.安装postcss-pxtorem
npm install postcss-pxtorem --save-dev

//4.修改postcss.config.js
module.exports = &#123;
  plugins: &#123;   //自己补充：插件
    //autoprefixer 自动补全css前缀的东西
    &#39;autoprefixer&#39;: &#123;
      //兼容的机型
      browsers: [&#39;Android &gt;= 4.0&#39;, &#39;iOS &gt;= 7&#39;]
    &#125;,
    &#39;postcss-pxtorem&#39;: &#123;
      rootValue: 37.5, //换算基数，一般和html的font-size一致
      propList: [&#39;*&#39;]  //哪些css属性需要换算
    &#125;
  &#125;
&#125;;
</code></pre>
<p>b) 使用postcss-px-to-viewport</p>
<pre><code>`vw` 与 `vh`单位，以`viewport`为基准，`1vw` 与 `1vh`分别为`window.innerWidth` 与 `window.innerHeight`的百分之一。

vw/vh 单位其实出现比较早了，只是以前支持性不太好，现在随着浏览器的发展，大部分（92%以上）的浏览器已经支持了vw/vh
</code></pre>
<pre><code class="javascript">npm i postcss-px-to-viewport -save -dev

//修改postcss.config.js
module.exports = &#123;
  plugins: &#123;
      autoprefixer: &#123;
          //兼容的机型
            browsers: [&#39;Android &gt;= 4.0&#39;, &#39;iOS &gt;= 7&#39;]
      &#125;,
    //px转换为vw单位的插件
    &quot;postcss-px-to-viewport&quot;: &#123;
      //1vw = 3.2
      viewportWidth: 320,
      //1vh = 5.68
      viewportHeight: 568,
      // px to vw无法整除时，保留几位小数
      unitPrecision: 5,
      // 转换成vw单位   
      viewportUnit: &#39;vw&#39;,
     //不转换的类名
      selectorBlackList: [],
      // 小于1px不转换
      minPixelValue: 1,
     //允许媒体查询中转换
      mediaQuery: false,
      //排除node_modules文件中第三方css文件
      exclude: /(\/|\\)(node_modules)(\/|\\)/  
    &#125;,
  &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:39:09.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-28_axios、fetch与ajax有什么区别"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundli0007psv9h98hht0w.html">28_axios、fetch与ajax有什么区别</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax指的是XMLHttpRequest（XHR）， 最早出现的发送后端请求技术，核心使用XMLHttpRequest对象，如果多个请求之间如果有先后关系的话，就会出现回调地狱。</p>
<p>JQuery ajax 是对原生XHR的封装，除此以外还增添了对JSONP的支持。经过多年的更新维护，真的已经是非常的方便了，优点无需多言</p>
<p>Ajax的缺点：<br>1.本身是针对MVC的编程,不符合现在前端MVVM的浪潮<br>2.基于原生的XHR开发，XHR本身的架构不清晰。<br>3.JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）<br>4.容易出现回调地狱的问题<br>5.不符合关注分离的原则</p>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>Vue2.0之后，尤雨溪推荐我们使用axios替换JQuery ajax。<br>axios 是一个基于Promise的请求库，用于浏览器和nodejs中，本质上浏览器的axios也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征：<br>1.从浏览器中创建 XMLHttpRequest<br>2.支持 Promise API<br>3.客户端支持防止CSRF<br>4.提供了一些并发请求的接口（重要，方便了很多的操作）<br>5.从node.js创建 http 请求<br>6.拦截请求和响应<br>7.转换请求和响应数据<br>8.取消请求<br>9.自动转换JSON数据</p>
<h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的，Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p>
<p>fetch的优点：<br>1.符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里<br>2.更好更方便的写法<br>3.基于标准 Promise 实现，支持 async/await<br>4.更加底层，提供的API丰富（request, response）<br>5.脱离了XHR，是ES6规范里新的实现方式</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:36:48.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-27_Promise对象"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundlf0004psv9c13odfom.html">27_Promise对象</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>Promise对象是ES6（ ECMAScript 2015 ）对于异步编程提供的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。<br>Promise本身不是异步的，只不过Promise中可以有异步任务，new Promise()的第一个函数参数是立马执行的。</p>
<pre><code>function func1(a)&#123;
    return new Promise((resolve,reject) =&gt; &#123;
        if(a &gt; 10)&#123;
            resolve(a)
        &#125;else&#123;
            reject(b)
        &#125;
    &#125;)
&#125;;

func1(&#39;11&#39;).then(res =&gt; &#123;
    console.log(&#39;success&#39;);
&#125;).catch(err =&gt; &#123;
    console.log(&#39;error&#39;);
&#125;)


//Promise构造函数接受一个函数作为参数，该函数的两个参数分别resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供。
1.resolve函数的作用是： 将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；

2.reject函数的作用是： 将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

//Promise对象实例的方法，then 和 catch：
1  .then方法： 用于指定调用成功时的回调函数。
    then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例），因此可以采用链式写法，即then方法后面再调用另一个then方法。

2  .catch方法： 用于指定发生错误时的回调函数。
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:35:28.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-26_vue-router实现动态加载路由组件"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundle0002psv96iew9v2y.html">26_vue-router实现动态加载路由组件</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>
<p>结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。</p>
<p>第一步：定义一个能够被 Webpack 自动代码分割的异步组件。</p>
<pre><code>//在src/router/index.js里面引入异步引入组件
const index = () =&gt; import(&#39;../page/list/index.vue&#39;);
</code></pre>
<p>第二步：在路由配置中什么都不需要改变，只需要像往常一样使用 index。</p>
<pre><code>const router = new VueRouter(&#123;
  routes: [
    &#123; path: &#39;/index&#39;, component: index,name:&quot;index&quot; &#125;
  ]
&#125;)
</code></pre>
<p>第三步：在build/webpack.base.conf.js下的output属性，新增chunkFilename。</p>
<pre><code>output: &#123;
    path: config.build.assetsRoot,
    filename: &#39;[name].js&#39;,
    //新增chunkFilename属性
    chunkFilename: &#39;[name].js&#39;,
    publicPath: process.env.NODE_ENV === &#39;production&#39;
      ? config.build.assetsPublicPath
      : config.dev.assetsPublicPath
  &#125;,
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:33:38.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-25_vue-router如何定义嵌套路由"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundlh0006psv976562exa.html">25_vue-router如何定义嵌套路由</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>嵌套路由  :  是路由的多层嵌套。</p>
<p><code>第一步：</code>需要在一个被渲染的组件中嵌套 <code>&lt;router-view&gt;</code>组件用于呈现子路由。</p>
<pre><code>const User = &#123;
  template: `
    &lt;div class=&quot;user&quot;&gt;
      &lt;h2&gt;User&lt;/h2&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
  `
&#125;
</code></pre>
<p><code>第二步：</code>在嵌套的出口中渲染组件，在<code>VueRouter</code> 的参数中使用<code>children</code>配置：</p>
<pre><code>const router = createRouter(&#123;
  routes: [
    &#123; 
      path: &#39;/user/:id&#39;, 
      component: User,
      children: [
        &#123;
          // 当 /user/:id/profile 匹配成功，
          // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中
          path: &#39;profile&#39;,
          component: UserProfile
        &#125;,
        &#123;
          // 当 /user/:id/posts 匹配成功
          // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中
          path: &#39;posts&#39;,
          component: UserPosts
        &#125;
      ]
    &#125;
  ]
&#125;)
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:31:49.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-24_vue-router导航解析流程"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundlf0003psv99lul6mkn.html">24_vue-router导航解析流程</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="vue-router导航钩子"><a href="#vue-router导航钩子" class="headerlink" title="vue-router导航钩子"></a>vue-router导航钩子</h2><pre><code>1、全局守卫： router.beforeEach  router.beforeResolve  router.afterEach
    const router = new VueRouter(&#123; ... &#125;);
    router.beforeEach((to, from, next) =&gt; &#123;
        // do someting
    &#125;);
    //to:代表要进入的目标，它是一个路由对象
    //from:代表当前正要离开的路由，同样也是一个路由对象
    //next:这是一个必须需要调用的方法，而具体的执行效果则依赖 next 方法调用的参数

    //全局后置钩子，后置钩子并没有 next 函数，也不会改变导航本身
    router.afterEach((to, from) =&gt; &#123;
        // do someting
    &#125;);

2、路由独享的守卫： beforeEnter
    cont router = new VueRouter(&#123;
        routes: [
            &#123;
                path: &#39;/file&#39;,
                component: File,
                beforeEnter: (to, from ,next) =&gt; &#123;
                    // do someting
                &#125;
            &#125;
        ]
    &#125;);
    
3、组件内的守卫： beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave
    const File = &#123;
        template: `&lt;div&gt;This is file&lt;/div&gt;`,
        beforeRouteEnter(to, from, next) &#123;
            // do someting
            // 在渲染该组件的对应路由被 confirm 前调用   confirm确定
        &#125;,
        beforeRouteUpdate(to, from, next) &#123;
            // do someting
            // 在当前路由改变，但是依然渲染该组件时调用
        &#125;,
        beforeRouteLeave(to, from ,next) &#123;
            // do someting
            // 导航离开该组件的对应路由时被调用
        &#125;
    &#125;
</code></pre>
<h2 id="vue-router导航解析流程"><a href="#vue-router导航解析流程" class="headerlink" title="vue-router导航解析流程"></a>vue-router导航解析流程</h2><p>localhost:8000/#a  —&gt; localhost:8000/#b<br>当由A路由 –&gt; B路由的时候：<br>1、在A组件里调用离开守卫。          A组件中的  beforeRouteLeave<br>2、调用全局的 beforeEach 守卫。    router.beforeEach<br>3、再执行B路由配置里调用 beforeEnter。</p>
<pre><code> routes: [
        &#123;
          path: &#39;/b&#39;,
          component: B,
          beforeEnter: (to, from, next) =&gt; &#123;
          &#125;
        &#125;
      ]
</code></pre>
<p>4、再执行B组件的进入守卫。          B组件中 beforeRouteEnter。<br>5、调用全局的 beforeResole 守卫 (2.5+)。    router.beforeResolve<br>6、导航被确认。<br>7、调用全局的 afterEach 钩子。              router.afterEach<br>8、触发 DOM 更新。</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:27:45.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-23_vue-router如何响应路由参数的变化"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundl70000psv98rbt5ltg.html">23_vue-router如何响应路由参数的变化</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <blockquote>
<p>问题：当使用路由参数时，例如从 <code>/content?id=1</code> 到 <code>content?id=2</code>，此时原来的组件实例会被复用。这也意味着组件的<code>生命周期钩子不会再被调用</code>，此时vue应该如何响应<code>路由参数</code> 的变化？</p>
</blockquote>
<p>解决方案：</p>
<p>1.用 :key 来阻止“复用”</p>
<pre><code>//在父组件中使用
&lt;router-view :key=&quot;key&quot;&gt;&lt;/router-view&gt;

computed: &#123;
    key() &#123;
        return this.$route.name !== undefined? this.$route.name +new Date(): this.$route +new Date()
    &#125;
&#125;

//这种办法实质上是让每次路由跳转时重新构建该组件，我们在它的生命周期中写一个打印语句就能看出来。
</code></pre>
<p>2.复用组件时，想对路由参数的变化作出响应的话， 可以<code>watch (监测变化) $route 对象</code>：</p>
<pre><code class="javascript">const User = &#123;
  template: &#39;...&#39;,
  watch: &#123;
    &#39;$route&#39; (to, from) &#123;
      // 对路由变化作出响应...
    &#125;
  &#125;
&#125;
</code></pre>
<p>3.通过 <code>vue-router </code>的钩子函数 <code>beforeRouteEnter </code> <code>beforeRouteUpdate</code>  <code>beforeRouteLeave</code></p>
<pre><code class="javascript">//localhost:3000/login/1   ---&gt;localhost:3000/login/2
beforeRouteEnter (to, from, next) &#123;
   // 在渲染该组件的对应路由被 confirm 前调用
   // 不！能！获取组件实例 `this`
   // 因为当钩子执行前，组件实例还没被创建
&#125;,
beforeRouteUpdate (to, from, next) &#123;
   // 在当前路由改变，但是该组件被复用时调用
   // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
   // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
   // 可以访问组件实例 `this`
&#125;,
beforeRouteLeave (to, from, next) &#123;
   // 导航离开该组件的对应路由时调用
   // 可以访问组件实例 `this`
&#125;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:26:17.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-23-vue-router如何响应路由参数的变化"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundlg0005psv90031dbi8.html">23_vue-router如何响应路由参数的变化</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <blockquote>
<p>问题：当使用路由参数时，例如从 <code>/content?id=1</code> 到 <code>content?id=2</code>，此时原来的组件实例会被复用。这也意味着组件的<code>生命周期钩子不会再被调用</code>，此时vue应该如何响应<code>路由参数</code> 的变化？</p>
</blockquote>
<p>解决方案：</p>
<p>1.用 :key 来阻止“复用”</p>
<pre><code>//在父组件中使用
&lt;router-view :key=&quot;key&quot;&gt;&lt;/router-view&gt;

computed: &#123;
    key() &#123;
        return this.$route.name !== undefined? this.$route.name +new Date(): this.$route +new Date()
    &#125;
&#125;

//这种办法实质上是让每次路由跳转时重新构建该组件，我们在它的生命周期中写一个打印语句就能看出来。
</code></pre>
<p>2.复用组件时，想对路由参数的变化作出响应的话， 可以<code>watch (监测变化) $route 对象</code>：</p>
<pre><code class="javascript">const User = &#123;
  template: &#39;...&#39;,
  watch: &#123;
    &#39;$route&#39; (to, from) &#123;
      // 对路由变化作出响应...
    &#125;
  &#125;
&#125;
</code></pre>
<p>3.通过 <code>vue-router </code>的钩子函数 <code>beforeRouteEnter </code> <code>beforeRouteUpdate</code>  <code>beforeRouteLeave</code></p>
<pre><code class="javascript">//localhost:3000/login/1   ---&gt;localhost:3000/login/2
beforeRouteEnter (to, from, next) &#123;
   // 在渲染该组件的对应路由被 confirm 前调用
   // 不！能！获取组件实例 `this`
   // 因为当钩子执行前，组件实例还没被创建
&#125;,
beforeRouteUpdate (to, from, next) &#123;
   // 在当前路由改变，但是该组件被复用时调用
   // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
   // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
   // 可以访问组件实例 `this`
&#125;,
beforeRouteLeave (to, from, next) &#123;
   // 导航离开该组件的对应路由时调用
   // 可以访问组件实例 `this`
&#125;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:26:17.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-22_自定义指令的钩子函数及其参数"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/ckzkundlc0001psv9hu3jf7ol.html">22_自定义指令的钩子函数及其参数</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="自定义指令的钩子函数"><a href="#自定义指令的钩子函数" class="headerlink" title="自定义指令的钩子函数"></a>自定义指令的钩子函数</h2><p>自定义组件就是实现Vue提供的钩子函数，在Vue3中钩子函数的生命周期和组件的生命周期类似：</p>
<pre><code>- created - 元素创建后，但是属性和事件还没有生效时调用。
- beforeMount- 仅调用一次，当指令第一次绑定元素的时候。
- mounted- 仅调用一次，元素被插入父元素时调用.
- beforeUpdate: 在更新包含组件的 VNode 之前调用。
- updated - 在包含组件的 VNode 及其子组件的 VNode 更新后调用。
- beforeUnmount: 元素卸载前调用，仅调用一次
- unmounted -当指令卸载后调用，仅调用一次
</code></pre>
<h2 id="自定义指令钩子函数参数"><a href="#自定义指令钩子函数参数" class="headerlink" title="自定义指令钩子函数参数"></a>自定义指令钩子函数参数</h2><blockquote>
<p>在自定义指令钩子函数的参数中，除了 el 之外，其它参数都应该是只读的，切勿进行修改。</p>
</blockquote>
<ul>
<li>每一个钩子函数都有如下参数：<ul>
<li>el: 指令绑定的元素，可以用来直接操作DOM</li>
<li>binding: 数据对象，包含以下属性   获取绑定的值<ul>
<li>instance: 当前组件的实例，一般推荐指令和组件无关，如果有需要使用组件上下文ViewModel，可以从这里获取</li>
<li>value: 指令的值，即上面示例中的“yellow“</li>
<li>oldValue: 指令的前一个值，在beforeUpdate和Updated 中，可以和value是相同的内容。</li>
<li>arg: 传给指令的参数，例如v-on:click中的click。</li>
<li>modifiers: 包含修饰符的对象。例如v-on.stop:click 可以获取到一个{stop:true}的对象</li>
</ul>
</li>
<li>vnode: Vue 编译生成的虚拟节点,</li>
<li>prevVNode: Update时的上一个虚拟节点</li>
</ul>
</li>
</ul>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-02-13T05:23:16.000Z" itemprop="datePublished">2022-02-13</time>
</div>
    
    
    </div>
</footer>

</article>

    
  

  
    <nav class="pagination">
        <a class="extend prev" rel="prev" href="/page/2/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">Next</a>
    </nav>
  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/" rel="tag">js的基本数据类型和引用数据类型详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8Enode%E5%90%8E%E7%AB%AF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="tag">mongodb的安装、使用，与node后端连接，前端的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%80%E4%B9%88%E6%98%AFMVVM%EF%BC%8CMVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E4%BB%A5%E5%8F%8A%E4%B8%8EMVC%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">什么是MVVM，MVVM模式的优点以及与MVC模式的区别</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E4%B8%89%E8%80%85%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86/" rel="tag">对三者的声明方式进行区分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E3%80%81%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="tag">对象的引用、浅拷贝、深拷贝在内存中的实现过程、三者的区别</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/ckzkw1mmm000098v96qneg6ml.html">51_es6常用语法</a>
          </li>
        
          <li>
            <a href="/ckzkvyzdq000cr0v92yrj72oj.html">50_js模块化规范</a>
          </li>
        
          <li>
            <a href="/ckzkvyzdp000ar0v98t6yeis5.html">49_JavaScript的严格模式</a>
          </li>
        
          <li>
            <a href="/ckzkvyzdo0009r0v9dtsgcq9p.html">48_减低页面加载时间的几种方法</a>
          </li>
        
          <li>
            <a href="/ckzkvyzdq000br0v9a5cjenzy.html">47_前端兼容问题的解决方案</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <div class="footer-wrap">
        <div class="footer-inner"> 
            小豆子的博客 &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1630473019367.js"></script>


<script src="/dist/custom.js?1630473019367.js"></script>









</body>

</html>